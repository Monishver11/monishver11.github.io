---
layout: post
title: DP Programming (Patterns and Problems)
date: 2025-01-20 12:11:00-0400
featured: false
description: A structured reference set of Dynamic Programming (DP) problems, directly adapted from Striver's DP playlist.
tags: DP Code
categories: DSA
giscus_comments: false
related_posts: false
toc:
  sidebar: left
---


#### **DP on Subsequences**

[Subset Sum Problem](https://www.geeksforgeeks.org/problems/subset-sum-problem-1611555638/1)
```c++
//{ Driver Code Starts

#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends
// User function template for C++

class Solution {
  public:
    // int fn(int idx, int target, vector<int>& arr, vector<vector<int>>& dp) {
    //     if(target==0) return true;
    //     if(idx==0) return (arr[0]==target);
    //     if(dp[idx][target]!=-1) return dp[idx][target];
    //     bool not_take = fn(idx-1, target, arr, dp);
    //     bool take = false;
    //     if(arr[idx]<=target) {
    //         take = fn(idx-1, target-arr[idx], arr, dp);
    //     }
        
    //     return dp[idx][target] = take||not_take;
    // }
    bool isSubsetSum(vector<int>& arr, int target) {
        int n = arr.size();
        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(target+1, -1));
        // return fn(n-1, target, arr, dp)==1;
        
        //Tabulation:
        // vector<vector<bool>> dp(n, vector<bool>(target+1, 0));
        // //Base cases;
        // for(int i=0; i<n; i++) dp[i][0]=true;
        // dp[0][arr[0]] = true;
        // //Building the steps;
        // for(int i=1; i<n; i++) {
        //     for(int j=1; j<=target; j++) {
        //         bool not_take = dp[i-1][j];
        //         bool take = false;
        //         if(arr[i]<=j) {
        //             take = dp[i-1][j-arr[i]];
        //         }
                
        //         dp[i][j] = take||not_take;
        //     }
        // }
        
        // return dp[n-1][target];
        
        //Tabulation + Space Optimization;
        vector<bool> prev(target+1, 0), cur(target+1, 0);
        //Base cases;
        prev[0] = true;
        prev[arr[0]] = true;
        //Building the steps;
        for(int i=1; i<n; i++) {
            cur[0] = true;
            for(int j=1; j<=target; j++) {
                bool not_take = prev[j];
                bool take = false;
                if(arr[i]<=j) {
                    take = prev[j-arr[i]];
                }
                cur[j] = take||not_take;
            }
            prev = cur;
        }
        return prev[target];
    }
};
```

[Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)
```c++
class Solution {
public:
    // int fn(int idx, int target, vector<int>& nums, vector<vector<int>>& dp) {
    //     if(target==0) return true;
    //     if(idx==0) return (nums[0]==target);
    //     if(dp[idx][target]!=-1) return dp[idx][target];
    //     bool not_take = fn(idx-1, target, nums, dp);
    //     bool take = false;
    //     if(nums[idx]<=target) {
    //         take = fn(idx-1, target-nums[idx], nums, dp);
    //     }
    //     return dp[idx][target] = take||not_take;
    // }
    bool canPartition(vector<int>& nums) {
        int n = nums.size();
        int totSum = 0;
        for(int i=0; i<n; i++) totSum+=nums[i];
        if(totSum%2!=0) return false;
        int target = totSum/2;

        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(target+1, -1));
        // return fn(n-1, target, nums, dp);

        //Tabulation:
        // vector<vector<bool>> dp(n, vector<bool>(target+1, 0));
        // //Base case;
        // for(int i=0; i<n; i++) dp[i][0] = true;
        // if(nums[0]<=target) dp[0][nums[0]] = true;
        // //Building the steps;
        // for(int i=1; i<n; i++) {
        //     for(int j=1; j<=target; j++) {
        //         bool not_take = dp[i-1][j];
        //         bool take = false;
        //         if(nums[i]<=j) {
        //             take = dp[i-1][j-nums[i]];
        //         }
        //         dp[i][j] = take||not_take;
        //     }
        // }
        // return dp[n-1][target]==1;

        //Tabulation + Space Optimization:
        vector<bool> prev(target+1, 0), cur(target+1, 0);
        //Base case;
        prev[0] = true;
        if(nums[0]<=target) prev[nums[0]] = true;
        //Building the steps;
        for(int i=1; i<n; i++) {
            cur[0] = true;
            for(int j=1; j<=target; j++) {
                bool not_take = prev[j];
                bool take = false;
                if(nums[i]<=j) {
                    take = prev[j-nums[i]];
                }
                cur[j] = take||not_take;
            }
            prev = cur;
        }
        return prev[target];
    }
};
```

[Array partition with minimum difference](https://www.naukri.com/code360/problems/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum._842494?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf)
```c++
int minSubsetSumDifference(vector<int>& nums, int n)
{
		int totSum = 0;
        for(int i=0; i<n; i++) totSum+=nums[i];

        int target = totSum;
        // //Now, Subset sum problem - Tabulation method;
        // vector<vector<bool>> dp(n, vector<bool>(target+1, 0));
        // for(int i=0; i<n; i++) dp[i][0]=true;
        // if(nums[0]<=target) dp[0][nums[0]]=true;
        // for(int i=1; i<n; i++) {
        //     for(int j=1; j<=target; j++) {
        //         bool not_take = dp[i-1][j];
        //         bool take = false;
        //         if(nums[i]<=j) {
        //             take = dp[i-1][j - nums[i]];
        //         }
        //         dp[i][j] = take||not_take;
        //     }
        // }
        // //Here, the dp[n-1][col->0...target] - will have T/F values indicating whether the targets(0...targets) are possible or not.
        // int mini = 1e9;
        // for(int i=0; i<=target; i++) {
        //     if(dp[n-1][i]==true) {
        //         mini = min(mini, abs((totSum-i)-i));
        //     }
        // }
        // return mini;

		//Now, Subset sum problem - Tabulation + Space Optimization method;
        vector<bool> prev(target+1, 0), cur(target+1, 0);
        for(int i=0; i<n; i++) prev[0]=true;
        if(nums[0]<=target) prev[nums[0]]=true;
        for(int i=1; i<n; i++) {
			cur[0] = true;
            for(int j=1; j<=target; j++) {
                bool not_take = prev[j];
                bool take = false;
                if(nums[i]<=j) {
                    take = prev[j - nums[i]];
                }
                cur[j] = take||not_take;
            }
			prev = cur;
        }
        //Here, the dp[n-1][col->0...target] - will have T/F values indicating whether the targets(0...targets) are possible or not.
        int mini = 1e9;
        for(int i=0; i<=target; i++) {
            if(prev[i]==true) {
                mini = min(mini, abs((totSum-i)-i));
            }
        }
        return mini;
}
```

[Perfect Sum Problem](https://www.geeksforgeeks.org/problems/perfect-sum-problem5633/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=perfect-sum-problem)
```c++
//{ Driver Code Starts
#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends
class Solution {
  public:
    // int fn(int idx, int target, vector<int>& arr, vector<vector<int>>& dp) {
    //     if(idx==0) {
    //         if(target==0 and arr[idx]==0) return 2;
    //         if(target==0 || target == arr[0]) return 1;
    //         return 0;
    //     }
    //     if(dp[idx][target]!=-1) return dp[idx][target];
    //     bool not_take = fn(idx-1, target, arr, dp);
    //     bool take = 0;
    //     if(arr[idx]<=target) {
    //         take = fn(idx-1, target-arr[idx], arr, dp);
    //     }
    //     return dp[idx][target] = take+not_take;
    // }
    int perfectSum(vector<int>& arr, int target) {
        int n = arr.size();
        //Memoizaiton: not working because the arr can contain 0. 
        //And, in that case, it can be both picked and not picked.
        // vector<vector<int>> dp(n, vector<int>(target+1, -1));
        // return fn(n-1, target, arr, dp);
        
        //Tabulation:
        vector<vector<int>> dp(n, vector<int>(target+1, 0));
        //for(int i=0; i<n; i++) dp[i][0]=1;
        
        if(arr[0]==0) dp[0][0]=2;
        else dp[0][0]=1;
        if(arr[0]!=0 and arr[0]<=target) dp[0][arr[0]] = 1;
        
        for(int i=1; i<n; i++) {
            for(int j=0; j<=target; j++) {
                int not_take = dp[i-1][j];
                int take = 0;
                if(arr[i]<=j) {
                    take = dp[i-1][j-arr[i]];
                }
                dp[i][j] = take+not_take;
            }
        }
        return dp[n-1][target];
    }
};
```

[Partitions with Given Difference](https://www.geeksforgeeks.org/problems/partitions-with-given-difference/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=partitions-with-given-difference)
```c++
//{ Driver Code Starts
// Initial function template for C++

#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends
class Solution {
  public:
    // int fn(int idx, int target, vector<int>& arr, vector<vector<int>>& dp) {
    //     if(idx==0) {
    //         if(target==0 and arr[0]==0) return 2;
    //         if(target==0 || arr[0]==target) return 1;
    //         else return 0;
    //     }
    //     if(dp[idx][target]!=-1) return dp[idx][target];
    //     int not_take = fn(idx-1, target, arr, dp);
    //     int take = false;
    //     if(arr[idx]<=target) {
    //         take = fn(idx-1, target-arr[idx], arr, dp);
    //     }
    //     return dp[idx][target] = take+not_take;
    // }
    // int subsetSum(int n, vector<int>& arr, int target) {
    //     vector<vector<int>> dp(n, vector<int>(target+1, -1));
    //     return fn(n-1, target, arr, dp);
    // }
    int countPartitions(vector<int>& arr, int d) {
        int totSum=0;
        for(int i=0; i<arr.size(); i++) totSum+=arr[i];
        if(totSum-d<0 || (totSum-d)%2) return 0;
        
        //Memoization:
        //return subsetSum(arr.size(), arr, (totSum-d)/2);
        int n = arr.size();
        int target = (totSum-d)/2;
        
        //Tabulation:
        // vector<vector<int>> dp(n, vector<int>(target+1, 0));
        // //Base cases
        // if(arr[0]==0) dp[0][0]=2;
        // else dp[0][0] = 1;
        // if(arr[0]!=0 and arr[0]<=target) dp[0][arr[0]]=1;
        
        // for(int i=1; i<n; i++) {
        //     for(int j=0; j<=target; j++) {
        //         int not_take = dp[i-1][j];
        //         int take = 0;
        //         if(arr[i]<=j) {
        //             take = dp[i-1][j-arr[i]];
        //         }
        //         dp[i][j] = take+not_take;
        //     }
        // }
        // return dp[n-1][target];
        
        //Tabulation + Space Optimization:
        vector<int> prev(target+1, 0), cur(target+1, 0);
        //Base cases
        if(arr[0]==0) prev[0]=2;
        else prev[0]=1;
        if(arr[0]!=0 and arr[0]<=target) prev[arr[0]]=1;
        
        for(int i=1; i<n; i++) {
            for(int j=0; j<=target; j++) {
                int not_take = prev[j];
                int take = 0;
                if(arr[i]<=j) {
                    take = prev[j-arr[i]];
                }
                cur[j] = take+not_take;
            }
            prev = cur;
        }
        return prev[target];
    }
};
```

[Coin Change](https://leetcode.com/problems/coin-change/)
```c++
class Solution {
public:
    // long fn(int idx, int T, vector<int> &coins, vector<vector<int>> & dp) {
    //     if(idx==0) {
    //         if(T%coins[idx]==0) return T/coins[idx];
    //         return INT_MAX;
    //     }
    //     if(dp[idx][T]!=-1) return dp[idx][T];
    //     long not_take = 0 + fn(idx-1, T, coins, dp);
    //     long take = INT_MAX;
    //     if(coins[idx]<=T) {
    //         take = 1 + fn(idx, T-coins[idx], coins, dp);
    //     }
    //     return dp[idx][T] = min(take, not_take);
    // }
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(amount+1, -1));
        // long ans = fn(n-1, amount, coins, dp);
        
        //Tabulation:
        // vector<vector<int>> dp(n, vector<int>(amount+1, 0));
        // //Base case;
        // for(int T=0; T<=amount; T++) {
        //     if(T%coins[0]==0) dp[0][T] = T/coins[0];
        //     else dp[0][T] = 1e9;
        // }
        // //Building the steps
        // for(int i=1; i<n; i++) {
        //     for(int T=0; T<=amount; T++) {
        //         int not_take = 0 + dp[i-1][T];
        //         int take = INT_MAX;
        //         if(coins[i]<=T) {
        //             take = 1 + dp[i][T-coins[i]];
        //         }
        //         dp[i][T] = min(take, not_take);
        //     }
        // }
        // int ans = dp[n-1][amount];

        //Tabulation + Space Optimization:
        vector<int> prev(amount+1, 0), cur(amount+1, 0);
        //Base case;
        for(int T=0; T<=amount; T++) {
            if(T%coins[0]==0) prev[T] = T/coins[0];
            else prev[T] = 1e9;
        }
        //Building the steps
        for(int i=1; i<n; i++) {
            for(int T=0; T<=amount; T++) {
                int not_take = 0 + prev[T];
                int take = 1e9;
                if(coins[i]<=T) {
                    take = 1 + cur[T-coins[i]];
                }
                cur[T] = min(take, not_take);
            }
            prev = cur;
        }
        int ans = prev[amount];

        if(ans >= 1e9) return -1;
        return (int)ans;
    }
};
```

[Target Sum](https://leetcode.com/problems/target-sum/)
```c++
class Solution {
public:
    // int fn(int idx, int target, vector<int> &nums, vector<vector<int>> &dp) {
    //     if(idx==0) {
    //         if(target==0 and nums[0]==0) return 2;
    //         if(target==0 || target==nums[0]) return 1;
    //         else return 0;
    //     }
    //     if(dp[idx][target]!=-1) return dp[idx][target];
    //     int not_take = fn(idx-1, target, nums, dp);
    //     int take = 0;
    //     if(nums[idx]<=target) {
    //         take = fn(idx-1, target-nums[idx], nums, dp);
    //     }
    //     return dp[idx][target] = take+not_take;
    // }
    int subsetSum(int n, int d, vector<int> &nums) {
        int totsum = 0;
        for(int i=0; i<n; i++) totsum+=nums[i];
        if((totsum-d)<0 || (totsum-d)%2) return 0;
        int target = (totsum-d)/2;
        
        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(target+1, -1));
        // return fn(n-1, target, nums, dp);
        
        //Tabulation:
        // vector<vector<int>> dp(n, vector<int>(target+1, 0));
        // //Base cases;
        // if(nums[0]==0) dp[0][0] = 2;
        // else dp[0][0] = 1;
        // if(nums[0]!=0 and nums[0]<=target) dp[0][nums[0]]=1;
        // //Bulding the states
        // for(int i=1; i<n; i++) {
        //     for(int j=0; j<=target; j++) {
        //         int not_take = dp[i-1][j];
        //         int take = 0;
        //         if(nums[i]<=j) {
        //             take = dp[i-1][j-nums[i]];
        //         }
        //         dp[i][j] = take+not_take;
        //     }
        // }
        // return dp[n-1][target];

        //Tabulation + Space Optimization:
        vector<int> prev(target+1, 0), cur(target+1, 0);
        //Base case;
        if(nums[0]==0) prev[0]=2;
        else prev[0]=1;
        if(nums[0]!=0 and nums[0]<=target) prev[nums[0]] = 1;
        for(int i=1; i<n; i++) {
            for(int j=0; j<=target; j++) {
                int not_take = prev[j];
                int take = 0;
                if(nums[i]<=j) {
                    take = prev[j-nums[i]];
                }
                cur[j] = take+not_take;
            }
            prev = cur;
        }
        return prev[target];
    }
    int findTargetSumWays(vector<int>& nums, int target) {
        int n = nums.size();
        int ans = subsetSum(n, target, nums);
        return ans;
    }
};
```

[Coin Change II](https://leetcode.com/problems/coin-change-ii/)
```c++
class Solution {
public:
    // int fn(int idx, int target, vector<int> &coins, vector<vector<int>> &dp) {
    //     if(idx==0) {
    //         return (target%coins[idx]==0);
    //     }
    //     if(dp[idx][target]!=-1) return dp[idx][target];
    //     int not_take = fn(idx-1, target, coins, dp);
    //     int take = 0;
    //     if(coins[idx]<=target) {
    //         take = fn(idx, target - coins[idx], coins, dp);
    //     }
    //     return dp[idx][target] = take+not_take;
    // } 
    int change(int amount, vector<int>& coins) {
        int n = coins.size();

        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(amount+1, -1));
        // return fn(n-1, amount, coins, dp);

        //Tabulation:
    //     vector<vector<double>> dp(n, vector<double>(amount+1, 0));
    //     //Base case;
    //     for(int i=0; i<=amount; i++) {
    //         if(i%coins[0]==0) dp[0][i] = 1; 
    //         else dp[0][i]=0;
    //     }
    //     //Building up the steps;
    //     for(int i=1; i<n; i++) {
    //         for(int j=0; j<=amount; j++) {
    //             double not_take = dp[i-1][j];
    //             double take = 0;
    //             if(coins[i]<=j) {
    //                 take = dp[i][j-coins[i]];
    //             }
    //             dp[i][j] = (take+not_take);
    //         }
    //     }
    //     return (int)dp[n-1][amount];
    

        //Tabulation + Space Optimization:
        vector<double> prev(amount+1, 0), cur(amount+1, 0);
        //Base case;
        for(int i=0; i<=amount; i++) {
            if(i%coins[0]==0) prev[i]=1;
            else prev[i]=0;
        }
        //Building up the steps;
        for(int i=1; i<n; i++) {
            for(int j=0; j<=amount; j++){
                double not_take = prev[j];
                double take = 0;
                if(coins[i]<=j) {
                    take = cur[j-coins[i]];
                }
                cur[j] = take+not_take;
            }
            prev=cur;
        }
        return (int)prev[amount];
    }
};
```

[Knapsack with Duplicate Items](https://www.geeksforgeeks.org/problems/knapsack-with-duplicate-items4201/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=knapsack-with-duplicate-items)
```c++
//{ Driver Code Starts
// Initial Template for C++

#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends
// User function Template for C++

class Solution {
  public:
    // int fn(int idx, int W, vector<int> &val, vector<int> &wt,
    // vector<vector<int>> &dp) {
    //     if(idx==0) {
    //         return ((int)(W/wt[0]))*val[0];
    //     }
    //     if(dp[idx][W]!=-1) return dp[idx][W];
    //     int not_take = 0 + fn(idx-1, W, val, wt, dp);
    //     int take = INT_MIN;
    //     if(wt[idx]<=W) {
    //         take = val[idx] + fn(idx, W-wt[idx], val, wt, dp);
    //     }
    //     return dp[idx][W] = max(take, not_take);
    // }
    int knapSack(vector<int>& val, vector<int>& wt, int W) {
        int n = val.size();
        
        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(W+1, -1));
        // return fn(n-1, W, val, wt, dp);
        
        //Tabulation:
        // vector<vector<int>> dp(n, vector<int>(W+1, 0));
        // //Base case;
        // for(int w=0; w<=W; w++) {
        //     dp[0][w] = ((int)(w/wt[0]))*val[0];
        // }
        // //Building the steps;
        // for(int i=1; i<n; i++) {
        //     for(int j=0; j<=W; j++) {
        //         int not_take = 0 + dp[i-1][j];
        //         int take = INT_MIN;
        //         if(wt[i]<=j) {
        //             take = val[i] + dp[i][j-wt[i]];
        //         }
        //         dp[i][j] = max(take, not_take);
        //     }
        // }
        // return dp[n-1][W];
        
        //Tabulation + Space Optimization:
        // vector<int> prev(W+1, 0), cur(W+1, 0);
        // //Base case;
        // for(int w=0; w<=W; w++) {
        //     prev[w] = ((int)(w/wt[0]))*val[0];
        // }
        // //Building the steps;
        // for(int i=1; i<n; i++) {
        //     for(int j=0; j<=W; j++) {
        //         int not_take = 0 + prev[j];
        //         int take = INT_MIN;
        //         if(wt[i]<=j) {
        //             take = val[i] + cur[j-wt[i]];
        //         }
        //         cur[j] = max(take, not_take);
        //     }
        //     prev = cur;
        // }
        // return prev[W];
        
        //Tabulation + 1D Space Optimization:
        vector<int> prev(W+1, 0);
        //Base case;
        for(int w=0; w<=W; w++) {
            prev[w] = ((int)(w/wt[0]))*val[0];
        }
        //Building the steps;
        for(int i=1; i<n; i++) {
            for(int j=0; j<=W; j++){
                int not_take = 0 + prev[j];
                int take = INT_MIN;
                if(wt[i]<=j) {
                    take = val[i] + prev[j-wt[i]];
                }
                prev[j] = max(take, not_take);
            }
        }
        return prev[W];
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    }
};
```

[Rod Cutting](https://www.geeksforgeeks.org/problems/rod-cutting0840/1)
```c++
//{ Driver Code Starts
// Initial Template for C++

#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends
// User function Template for C++

class Solution {
  public:
    int fn(int idx, int N, vector<int> & price, vector<vector<int>> &dp) {
        if(idx==0) {
            return N*price[0];
        }
        if(dp[idx][N]!=-1) return dp[idx][N];
        int not_take = 0 + fn(idx-1, N, price, dp);
        int take = INT_MIN;
        int rodLength = idx+1;
        if(rodLength<=N) {
            take = price[idx] + fn(idx, N - rodLength, price, dp);
        }
        return dp[idx][N] = max(take, not_take);
    }
    int cutRod(vector<int> &price) {
        int n = price.size();
        
        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(n+1, -1));
        // return fn(n-1, n, price, dp);
        
        //Tabulation:
        // vector<vector<int>> dp(n, vector<int>(n+1, 0));
        // //Base case;
        // for(int i=0; i<=n; i++) {
        //     dp[0][i] = i*price[0];
        // }
        // //Building the steps;
        // for(int i=1; i<n; i++) {
        //     for(int j=0; j<=n; j++) {
        //         int not_take = 0 + dp[i-1][j];
        //         int take = INT_MIN;
        //         int rodLength = i+1;
        //         if(rodLength<=j) {
        //             take = price[i] + dp[i][j-rodLength];
        //         }
        //         dp[i][j] = max(take, not_take);
        //     }
        // }
        // return dp[n-1][n];
        
        //Tabulation + Space Optimization:
        // vector<int> prev(n+1, 0), cur(n+1, 0);
        // //Base case;
        // for(int i=0; i<=n; i++) {
        //     prev[i] = i*price[0];
        // }
        // //Building the steps;
        // for(int i=1; i<n; i++) {
        //     for(int j=0; j<=n; j++) {
        //         int not_take = 0 + prev[j];
        //         int take = INT_MIN;
        //         int rodLength = i+1;
        //         if(rodLength<=j) {
        //             take = price[i] + cur[j-rodLength];
        //         }
        //         cur[j] = max(take, not_take);
        //     }
        //     prev = cur;
        // }
        // return prev[n];
        
        //Tabulation + 1D Space Optimization:
        vector<int> prev(n+1, 0);
        //Base case;
        for(int i=0; i<=n; i++) {
            prev[i] = i*price[0];
        }
        //Building the steps;
        for(int i=1; i<n; i++) {
            for(int j=0; j<=n; j++) {
                int not_take = 0 + prev[j];
                int take = INT_MIN;
                int rodLength = i+1;
                if(rodLength<=j) {
                    take = price[i] + prev[j-rodLength];
                }
                prev[j] = max(take, not_take);
            }
        }
        return prev[n];
    }
};
```

---
#### **DP on Strings**

[Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)
```c++
class Solution {
public:
    // int fn(int i, int j, string &s1, string &s2, vector<vector<int>> &dp) {
    //     if(i<0 || j<0) return 0;
    //     if(dp[i][j]!=-1) return dp[i][j];
    //     if(s1[i]==s2[j]) return dp[i][j] =  1 + fn(i-1, j-1, s1, s2, dp);
    //     return dp[i][j] = 0 + max(fn(i-1, j, s1, s2, dp), fn(i, j-1, s1, s2, dp));
    // }
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size();
        int m = text2.size();

        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(m, -1));
        // return fn(n-1, m-1, text1, text2, dp);

        //Tabulation:
        // vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
        // //Base case;
        // for(int i=0; i<=n; i++) dp[i][0] = 0;
        // for(int j=0; j<=m; j++) dp[0][j] = 0;
        // //Building the steps;
        // for(int i=1; i<=n; i++) {
        //     for(int j=1; j<=m; j++) {
        //         if(text1[i-1]==text2[j-1]) dp[i][j] = 1 + dp[i-1][j-1];
        //         else dp[i][j] = 0 + max(dp[i-1][j], dp[i][j-1]);
        //     }
        // }
        // return dp[n][m];

        //Tabulation + Space Optimization:
        vector<int> prev(m+1, 0), cur(m+1, 0);
        //Base case;
        for(int i=0; i<=m; i++) prev[i] = 0;
        //Building the steps;
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=m; j++) {
                if(text1[i-1]==text2[j-1]) cur[j] = 1 + prev[j-1];
                else cur[j] = 0 + max(cur[j-1], prev[j]);
            }
            prev = cur;
        }
        return prev[m];
    }
};
```
[Print all LCS sequences](https://www.geeksforgeeks.org/problems/print-all-lcs-sequences3413/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=print-all-lcs-sequences)
```c++
//{ Driver Code Starts
#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends
class Solution {
  public:
    vector<string> all_longest_common_subsequences(string s, string t) {
        //Tabulation method to find the LCS(Count):
        int n = s.size();
        int m = t.size();
        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
        //Base case;
        for(int i=0; i<=n; i++) dp[i][0] = 0;
        for(int j=0; j<=m; j++) dp[0][j] = 0;
        //Building the steps;
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=m; j++) {
                if(s[i-1]==t[j-1]) dp[i][j] = 1 + dp[i-1][j-1];
                else dp[i][j] = 0 + max(dp[i-1][j], dp[i][j-1]);
            }
        }
        int lcs_len = dp[n][m];
        //cout<<lcs_len<<endl;
        //Print all the sub-sequence thats present with lcs calculation;
        int i = n-1;
        int j = m-1;
        vector<string> ans;
        string tmp = "X";
        for(int i=1; i<lcs_len; i++) tmp+='X';
        while(i>=0 and j>=0) {
            if(s[i]==t[j]) {
                tmp[lcs_len-1] = s[i];
                i--;
                j--;
                lcs_len--;
            }
            else if(dp[i-1][j]>dp[i][j]) {
                i--;
            }
            else j--;
        }
        //cout<<tmp<<endl;
        ans.push_back(tmp);
        return ans;
    }
};
```
[Longest Common Substring](https://www.geeksforgeeks.org/problems/longest-common-substring1452/1)
```c++
//{ Driver Code Starts
#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends
class Solution {
  public:
    int longestCommonSubstr(string& s1, string& s2) {
        int n = s1.size();
        int m = s2.size();
        int ans = 0;
        //Tabulation:
        // vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
        // //Base case;
        // for(int i=0; i<=n; i++) dp[i][0] = 0;
        // for(int j=0; j<=m; j++) dp[0][j] = 0;
        // //building the steps;
        // for(int i=1; i<=n; i++) {
        //     for(int j=1; j<=m; j++) {
        //         if(s1[i-1]==s2[j-1]) {
        //             dp[i][j] = 1 + dp[i-1][j-1];
        //             ans = max(ans, dp[i][j]);
        //         }
        //         else dp[i][j] = 0;
        //     }
        // }
        // return ans;
        
        //Tabulation + Space Optimization:
        vector<int> prev(m+1, 0), cur(m+1, 0);
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=m; j++) {
                if(s1[i-1]==s2[j-1]) {
                    cur[j] = 1 + prev[j-1];
                    ans = max(ans, cur[j]);
                }
                else cur[j] = 0;
            }
            prev = cur;
        }
        return ans;
    }
};
```
[Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)
```c++
class Solution {
public:
    int fn(int i, int j, string s, string t, vector<vector<int>> & dp) {
        if(i<0 || j<0) return 0;
        if(dp[i][j]!=-1) return dp[i][j];
        if(s[i]==t[j]) return dp[i][j] = 1 + fn(i-1, j-1, s, t, dp);
        return dp[i][j] = 0 + max(fn(i-1, j, s, t, dp), fn(i, j-1, s, t, dp));
    }
    int longestPalindromeSubseq(string s) {
        string t = s;
        reverse(t.begin(), t.end());
        int n = s.size();

        //Memoization: MLE - Memory Limit Exceeded
        // vector<vector<int>> dp(n, vector<int>(n, -1));
        // return fn(n-1, n-1, s, t, dp);

        //Tabulation:
        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=n; j++) {
                if(s[i-1]==t[j-1]) dp[i][j] = 1 + dp[i-1][j-1];
                else dp[i][j] = 0 + max(dp[i][j-1], dp[i-1][j]);
            }
        }
        return dp[n][n];

        //Tabulation  + Space Optimization:
        vector<int> prev(n+1, 0), cur(n+1, 0);
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=n; j++) {
                if(s[i-1]==t[j-1]) cur[j] = 1 + prev[j-1];
                else cur[j] = 0 + max(prev[j], prev[j-1]);
            }
            prev = cur;
        }
        return prev[n];
    }
};
```
[Minimum Insertion Steps to Make a String Palindrome](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)
```c++
class Solution {
public:
    int lcs(string &s, string &t) {
        int n = s.size();
        int m = t.size();

        //Tabulation:
        // vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
        // for(int i=1; i<=n; i++) {
        //     for(int j=1; j<=m; j++) {
        //         if(s[i-1]==t[j-1]) dp[i][j] = 1 + dp[i-1][j-1];
        //         else dp[i][j] = 0 + max(dp[i-1][j], dp[i][j-1]);
        //     }
        // }
        // return dp[n][m];

        //Tabulation + Space Optmization:
        vector<int> prev(m+1, 0), cur(m+1, 0);
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=m; j++) {
                if(s[i-1]==t[j-1]) cur[j] = 1 + prev[j-1];
                else cur[j] = 0 + max(cur[j-1], prev[j]);
            }
            prev = cur;
        }
        return prev[m];
    }
    int minInsertions(string s) {
        //Via Longest Palindromic Subsequence;
        string t = s;
        reverse(t.begin(), t.end());
        return (s.size() - lcs(s, t));
        
    }
};
```

[Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)
```c++
class Solution {
public:
    int lcs(string &s, string &t) {
        int n = s.size();
        int m = t.size();

        //Tabulation:
        // vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
        // for(int i=1; i<=n; i++) {
        //     for(int j=1; j<=m; j++) {
        //         if(s[i-1]==t[j-1]) dp[i][j] = 1 + dp[i-1][j-1];
        //         else dp[i][j] = 0 + max(dp[i][j-1], dp[i-1][j]);
        //     }
        // }
        // return dp[n][m];

        //Tabulation + Space Optimization:
        vector<int> prev(m+1, 0), cur(m+1, 0);
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=m; j++) {
                if(s[i-1]==t[j-1]) cur[j] = 1 + prev[j-1];
                else cur[j] = 0 + max(cur[j-1], prev[j]);
            }
            prev = cur;
        }
        return prev[m];
    }
    int minDistance(string word1, string word2) {
        //Via LCS Approach;
        return (word1.size() + word2.size() - 2*lcs(word1, word2));
    }
};
```
[Shortest Common Supersequence](https://leetcode.com/problems/shortest-common-supersequence/)
```c++
class Solution {
public:
    string shortestCommonSupersequence(string s, string t) {
        //via LCS approach;
        int n = s.size();
        int m = t.size();
        //Tabulation: Need to build the DP table to identify this string. If it's the size of the shortest common supersequence, then we can use the tabulation with space optmization(without the dp table);
        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=m; j++) {
                if(s[i-1]==t[j-1]) dp[i][j] = 1 + dp[i-1][j-1];
                else dp[i][j] = 0 + max(dp[i-1][j], dp[i][j-1]);
            }
        }
        // dp[n][m] has the LCS size;
        int i = n;
        int j = m;
        string ans = "";
        while(i>0 and j>0) {
            if(s[i-1]==t[j-1]) {
                ans+=s[i-1];
                i--;
                j--;
            }
            else if(dp[i-1][j] > dp[i][j-1]) {
                ans+=s[i-1];
                i--;
            }
            else {
                ans+=t[j-1];
                j--;
            }
        }
        while(i>0) {ans+=s[i-1]; i--;}
        while(j>0) {ans+=t[j-1]; j--;}
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```
[Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences/)
```c++
class Solution {
public:
    // int fn(int i, int j, string &s, string &t, vector<vector<double>> &dp) {
    //     if(j==0) return 1;
    //     if(i==0) return 0;
    //     if(dp[i][j]!=-1) return dp[i][j];
    //     if(s[i-1]==t[j-1]) {
    //         return dp[i][j] = fn(i-1, j-1, s, t, dp) + fn(i-1, j, s, t, dp);
    //     }
    //     return dp[i][j] = fn(i-1, j, s, t, dp);
    // }
    int numDistinct(string s, string t) {
        int n = s.size();
        int m = t.size();

        //Memoization:
        // vector<vector<double>> dp(n+1, vector<double>(m+1, -1));
        // return (int)fn(n, m, s, t, dp);

        //Tabulation:
        // vector<vector<double>> dp(n+1, vector<double>(m+1, 0));
        // //Base case;
        // for(int i=0; i<=n; i++) dp[i][0] = 1;
        // for(int j=1; j<=m; j++) dp[0][j] = 0;
        // //Building the steps;
        // for(int i=1; i<=n; i++) {
        //     for(int j=1; j<=m; j++) {
        //         if(s[i-1]==t[j-1]) {
        //             dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
        //         }
        //         else dp[i][j] = dp[i-1][j];
        //     }
        // }
        // return dp[n][m];

        //Tabulation + Space Optimization:
        // vector<double> prev(m+1, 0), cur(m+1, 0);
        // prev[0] = cur[0] = 1;
        // for(int i=1; i<=n; i++) {
        //     for(int j=1; j<=m; j++) {
        //         if(s[i-1]==t[j-1]) {
        //             cur[j] = prev[j-1] + prev[j];
        //         }
        //         else {
        //             cur[j] = prev[j];
        //         }
        //     }
        //     prev = cur;
        // }
        // return (int)prev[m];

        //Tabulation + 1D Array Space Optimization:
        vector<double> prev(m+1, 0);
        prev[0] = 1;
        for(int i=1; i<=n; i++) {
            //Iterate from back: This is needed
            for(int j=m; j>=1; j--) {
                if(s[i-1]==t[j-1]) {
                    prev[j] = prev[j-1] + prev[j];
                }
            }
        }
        return (int)prev[m];
    }
};
```
[Edit Distance](https://leetcode.com/problems/edit-distance/)
```c++
class Solution {
public:
    // int fn(int i, int j, string &s, string &t,
    // vector<vector<int>> &dp) {
    //     //Base case;
    //     if(i<0) return j+1;
    //     if(j<0) return i+1;
    //     if(dp[i][j]!=-1) return dp[i][j];
    //     //Recurrence;
    //     if(s[i]==t[j]) return dp[i][j] = 0 + fn(i-1, j-1, s, t, dp);
    //     return dp[i][j] =  1 + min(
    //         fn(i, j-1, s, t, dp), //insert;
    //         min(fn(i-1, j, s, t, dp), //delete;
    //         fn(i-1, j-1, s, t, dp) //replace;
    //         )
    //     );

    // }
    int minDistance(string s, string t) {
        int n = s.size();
        int m = t.size();

        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(m, -1));
        // return fn(n-1, m-1, s, t, dp);

        //Tabulation:
        // vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
        // //Base case;
        // for(int i=0; i<=n; i++) dp[i][0] = i;
        // for(int j=0; j<=m; j++) dp[0][j] = j;
        // //Building the steps;
        // for(int i=1; i<=n; i++) {
        //     for(int j=1; j<=m; j++) {
        //         if(s[i-1]==t[j-1]) {
        //             dp[i][j] = 0 + dp[i-1][j-1];
        //         }
        //         else {
        //             dp[i][j] = 1 + min(
        //                 dp[i][j-1], //insert;
        //                 min(
        //                     dp[i-1][j], //delete;
        //                     dp[i-1][j-1] //replace;
        //                 )
        //             );
        //         }
        //     }
        // }
        // return dp[n][m];

        //Tabulation + Space Optmization:
        vector<int> prev(m+1, 0), cur(m+1, 0);
        //Base case;
        for(int j=0; j<=m; j++) prev[j] = j;
        //Building the steps;
        for(int i=1; i<=n; i++) {
            cur[0] = i;
            for(int j=1; j<=m; j++) {
                if(s[i-1]==t[j-1]) {
                    cur[j] = 0 + prev[j-1];
                }
                else {
                    cur[j] = 1 + min(
                        cur[j-1], //insert
                        min(
                            prev[j], //delete
                            prev[j-1]
                        )
                    );
                }
            }
            prev = cur;
        }
        return prev[m];
    }
};
```
[Wildcard Matching](https://leetcode.com/problems/wildcard-matching/)
```c++
class Solution {
public:
    // bool fn(int i, int j, string &p, string &s, vector<vector<int>> &dp) {
    //     //Base cases;
    //     if(i<0 && j<0) return 1;
    //     if(i<0 && j>=0) return 0;
    //     if(j<0 && i>=0) {
    //         //This case is due to * can take empty/any no. of chars;
    //         for(int ii=0; ii<=i; ii++) {
    //             if(p[ii]!='*') return 0;
    //         }
    //         return 1;
    //     }
    //     if(dp[i][j]!=-1) return dp[i][j];
    //     //Recurrence;
    //     if(p[i]==s[j] || p[i]=='?') return dp[i][j] = fn(i-1, j-1, p, s, dp);
    //     else if(p[i]=='*') {
    //         return dp[i][j] =  (fn(i-1, j, p, s, dp) // * taken as empty char and moved on;
    //         ||
    //         fn(i, j-1, p, s, dp) // * taken as the jth char
    //         );
    //     }
    //     else return dp[i][j] = 0;
    // }
    bool isMatch(string s, string p) {
        int n = p.size();
        int m = s.size();

        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(m, -1));
        // return (bool)fn(n-1, m-1, p, s, dp);

        //Tabulation:
        // vector<vector<bool>> dp(n+1, vector<bool>(m+1, false));
        // //Base cases;
        // dp[0][0] = true;
        // for(int j=0; j<=m; j++) dp[0][j] = false; //Check: j starts from 1 right?
        // for(int i=0; i<=n; i++) {
        //     bool flag = true;
        //     for(int ii = 1; ii<=i; ii++) {
        //         if(p[ii-1]!='*') {
        //             flag = false;
        //             break;
        //         }
        //     }
        //     dp[i][0] = flag;
        // }
        // //Building the steps;
        // for(int i=1; i<=n; i++) {
        //     for(int j=1; j<=m; j++) {
        //         if(p[i-1]==s[j-1] || p[i-1]=='?') {
        //             dp[i][j] = dp[i-1][j-1];
        //         } 
        //         else if(p[i-1]=='*') {
        //             dp[i][j] = dp[i-1][j] // * as empty char 
        //                         || dp[i][j-1]; // * as jth char
        //         }
        //         else dp[i][j] = false;
        //     }
        // }
        // return dp[n][m];

        //Tabulation + Space Optimization:
        vector<bool> prev(m+1, false), cur(m+1, false);
        //Base cases;
        prev[0] = true;
        //Building the steps;
        for(int i=1; i<=n; i++) {
            bool flag = true;
            for(int ii=1; ii<=i; ii++) {
                if(p[ii-1]!='*') {
                    flag=false;
                    break;
                }
            }
            cur[0] = flag;
            for(int j=1; j<=m; j++) {
                if(p[i-1]==s[j-1] || p[i-1]=='?') {
                    cur[j] = prev[j-1];
                }
                else if(p[i-1]=='*') {
                    cur[j] = prev[j] // * as empty char
                            || cur[j-1]; // * as jth char
                }
                else cur[j] = false;
            }
            prev = cur;
        }
        return prev[m];
    }
};
```
---
#### **DP on Stocks**

[Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        int mini = prices[0];
        for(int i=1; i<prices.size(); i++) {
            int cost = prices[i] - mini;
            profit = max(profit, cost);
            mini = min(mini, prices[i]);
        }
        return profit;
    }
};
```
[Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)
```c++
class Solution {
public:
    // int fn(int idx, int buy, vector<int> &prices, int n, 
    // vector<vector<int>> &dp) {
    //     //Base case;
    //     if(idx==n) return 0; // If i hold/not hold any stock, after the n days, the profit i have is 0, as i'm bound to make profit within n-1 days.
    //     //Recurrence;
    //     if(dp[idx][buy]!=-1) return dp[idx][buy];
    //     int profit = 0;
    //     if(buy) {
    //         profit = max(
    //             -prices[idx] + fn(idx+1, 0, prices, n, dp), //i've choose to buy and in the next idx i can't buy before selling;
    //             0 + fn(idx+1, 1, prices, n, dp) //i've choose not to buy, so in the next idx, i can buy;
    //         );
    //     }
    //     else {
    //         profit = max(
    //             prices[idx] + fn(idx+1, 1, prices, n, dp), //choose to sell, so in the next idx i can buy if i want;
    //             0 + fn(idx+1, 0, prices, n, dp) //choose to not sell, so in the next idx, i can't buy/sell;
    //         );
    //     }
    //     return dp[idx][buy] = profit;
    // }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        //Memoization:
        // vector<vector<int>> dp(n+1, vector<int>(2, -1));
        // return fn(0, 1, prices, n, dp);

        //Tabulation:
        // vector<vector<int>> dp(n+1, vector<int>(2, 0));
        // //Base case;
        // dp[n][0] = dp[n][1] = 0;
        // //Building the steps;
        // for(int idx=n-1; idx>=0; idx--) {
        //     for(int buy=0; buy<=1; buy++) {
        //         int profit = 0;
        //         if(buy) {
        //             profit = max(
        //                 -prices[idx] + dp[idx+1][0],
        //                 0 + dp[idx+1][1]
        //             );
        //         }
        //         else {
        //             profit = max(
        //                 prices[idx] + dp[idx+1][1],
        //                 0 + dp[idx+1][0]
        //             );
        //         }
        //         dp[idx][buy] = profit;
        //     }
        // }
        // return dp[0][1];

        //Tabualtion + Space optmization:
        vector<int> ahead(2, 0), cur(2, 0);
        //Base case;
        ahead[0] = ahead[1] = 0;
        //Building the steps;
        for(int idx=n-1; idx>=0; idx--) {
            for(int buy=0; buy<=1; buy++) {
                int profit = 0;
                if(buy) {
                    profit = max(
                        -prices[idx] + ahead[0],
                        0 + ahead[1]
                    );
                }
                else {
                    profit = max(
                        prices[idx] + ahead[1],
                        0 + ahead[0]
                    );
                }
                cur[buy] = profit;
            }
            ahead = cur;
        }
        return ahead[1];
    }
};
```
[Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)
```c++
class Solution {
public:
    // int fn(int idx, int buy, int cap, vector<int> &prices, int n, 
    // vector<vector<vector<int>>> &dp) {
    //     //Base case;
    //     if(idx==n || cap==0) return 0;
    //     //Recurrence;
    //     if(dp[idx][buy][cap]!=-1) return dp[idx][buy][cap];
    //     int profit = 0;
    //     if(buy) {
    //         profit = max(
    //             -prices[idx] + fn(idx+1, 0, cap, prices, n, dp),
    //             0 + fn(idx+1, 1, cap, prices, n, dp)
    //         );
    //     }
    //     else {
    //         profit = max(
    //             prices[idx] + fn(idx+1, 1, cap-1, prices, n, dp),
    //             0 + fn(idx+1, 0, cap, prices, n, dp)
    //         );
    //     }
    //     return dp[idx][buy][cap] = profit;
    // }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int k = 2; //Cap - Generalization to at most k transactions;

        //Memoization:
        // vector<vector<vector<int>>> dp(n, vector<vector<int>>(2, vector<int>(k+1, -1)));
        // return fn(0, 1, k, prices, n, dp);

        //Tabulation:
        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(k+1, 0)));
        //Base case;
        //It sets to zero in specific cases, but we've default values of zero already set, so no needed to define.
        //Recurrence;
        for(int idx=n-1; idx>=0; idx--) {
            for(int buy=0; buy<=1; buy++) {
                for(int cap = 1; cap<=k; cap++) {
                    int profit = 0;
                    if(buy) {
                        profit = max(
                            -prices[idx] + dp[idx+1][0][cap],
                            0 + dp[idx+1][1][cap]
                        );
                    }
                    else {
                        profit = max(
                            prices[idx] + dp[idx+1][1][cap-1],
                            0 + dp[idx+1][0][cap]
                        );
                    }
                    dp[idx][buy][cap] = profit;
                }
            }
        }
        return dp[0][1][k];

        //Tabulation + Space Optimization:
        vector<vector<int>> after(2, vector<int>(k+1, 0)), 
            cur(2, vector<int>(k+1, 0));
        //Base case;
        //Alreay covered with default values
        //Recurrence;
        for(int idx=n-1; idx>=0; idx--) {
            for(int buy=0; buy<=1; buy++) {
                for(int cap=1; cap<=k; k++) {
                    int profit = 0;
                    if(buy) {
                        profit = max(
                            -prices[idx] + after[0][cap],
                            0 + after[1][cap]
                        );
                    }
                    else {
                        profit = max(
                            prices[idx] + after[1][cap-1],
                            0 + after[0][cap]
                        );
                    }
                    cur[buy][cap] = profit;
                }
            }
        }
        return after[1][k];
    }
};
```
[Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)
```c++
class Solution {
public:
    // int fn(int idx, int trxNo, vector<int> &prices, int n, int k, 
    // vector<vector<int>> &dp) {
    //     //Base case;
    //     if(idx==n || trxNo==2*k+1) return 0;
    //     //Recurrence;
    //     if(dp[idx][trxNo]!=-1) return dp[idx][trxNo];
    //     int profit = 0;
    //     if(trxNo%2==0) { //Buy;
    //         profit = max(
    //             -prices[idx] + fn(idx+1, trxNo+1, prices, n, k, dp),
    //             0 + fn(idx+1, trxNo, prices, n, k, dp)
    //         );
    //     }
    //     else {
    //         profit= max(
    //             prices[idx] + fn(idx+1, trxNo+1, prices, n, k, dp),
    //             0 + fn(idx+1, trxNo, prices, n, k, dp)
    //         );
    //     }
    //     return dp[idx][trxNo] = profit;
    // }
    int maxProfit(int k, vector<int>& prices) {
        //A different approach from Buy and Sell Stock Problem III
        int n = prices.size();

        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(2*k+1, -1));
        // return fn(0, 0, prices, n, k, dp);

        //Tabulation:
        // vector<vector<int>> dp(n+1, vector<int>(2*k+1, 0));
        // //Base case;
        // //Already populated with default values 0;
        // //Recurrence;
        // for(int idx=n-1; idx>=0; idx--) {
        //     for(int trxNo=2*k-1; trxNo>=0; trxNo--) {
        //         int profit = 0;
        //         if(trxNo%2==0) { //Buy;
        //             profit = max(
        //                 -prices[idx] + dp[idx+1][trxNo+1],
        //                 0 + dp[idx+1][trxNo]
        //             );
        //         }
        //         else {
        //             profit = max(
        //                 prices[idx] + dp[idx+1][trxNo+1],
        //                 0 + dp[idx+1][trxNo]
        //             );
        //         }
        //         dp[idx][trxNo] = profit;
        //     }
        // }
        // return dp[0][0];

        //Tabulation + Space Optimization:
        vector<int> after(2*k+1, 0), cur(2*k+1, 0);
        //Base case;
        //Already filled with default values;
        //Recurrence;
        for(int idx=n-1; idx>=0; idx--) {
            for(int trxNo = 2*k-1; trxNo>=0; trxNo--) {
                int profit = 0;
                if(trxNo%2==0) { //Buy;
                    profit = max(
                        -prices[idx] + after[trxNo+1],
                        0 + after[trxNo]
                    );
                }
                else {
                    profit = max(
                        prices[idx] + after[trxNo+1],
                        0 + after[trxNo]
                    );
                }
                cur[trxNo] = profit;
            }
            after = cur;
        }
        return after[0];
    }
};
```
[Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
```c++
class Solution {
public:
    // int fn(int idx, int buy, vector<int> &prices, int n,
    // vector<vector<int>> &dp) {
    //     //Base case;
    //     if(idx>=n) return 0;
    //     //Recurrence;
    //     if(dp[idx][buy]!=-1) return dp[idx][buy];
    //     int profit=0;
    //     if(buy==1) {
    //         profit = max(
    //             -prices[idx] + fn(idx+1, 0, prices, n, dp),
    //             0 + fn(idx+1, 1, prices, n, dp)
    //         );
    //     }
    //     else {
    //         profit = max(
    //             prices[idx] + fn(idx+2, 1, prices, n, dp),
    //             0 + fn(idx+1, 0, prices, n, dp)
    //         );
    //     }
    //     return dp[idx][buy] = profit;
    // }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();

        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(2, -1));
        // return fn(0, 1, prices, n, dp);

        //Tabulation:
        // vector<vector<int>> dp(n+2, vector<int>(2, 0));
        // //Base case: not required, as its already defaulted with 0, which we need to populate for this case;
        // //Recurrence;
        // for(int i=n-1; i>=0; i--) {
        //     for(int buy=0; buy<=1; buy++) {
        //         int profit = 0;
        //         if(buy==1) {
        //             profit = max(
        //                 -prices[i] + dp[i+1][0],
        //                 0 + dp[i+1][1]
        //             );
        //         }
        //         else {
        //             profit = max(
        //                 prices[i] + dp[i+2][1],
        //                 0 + dp[i+1][0]
        //             );
        //         }
        //         dp[i][buy] = profit;
        //     }
        // }
        // return dp[0][1];

        //Tabulation + Space Optimization:
        vector<int> ahead2(2, 0), ahead(2, 0), cur(2, 0);
        //Base case: not required, reason same as above;
        //Recurrence;
        for(int i=n-1; i>=0; i--) {
            for(int buy=0; buy<=1; buy++) {
                int profit=0;
                if(buy==1) {
                    profit = max(
                        -prices[i] + ahead[0],
                        0 + ahead[1]
                    );
                }
                else {
                    profit = max(
                        prices[i] + ahead2[1],
                        0 + ahead[0]
                    );
                }
                cur[buy] = profit;
            }
            ahead2 = ahead;
            ahead = cur;
        }
        return ahead[1];
    }
};
```
[Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
```c++
class Solution {
public:
    // int fn(int idx, int buy, vector<int> &prices, int n, int fee,
    // vector<vector<int>> &dp) {
    //     //Base case;
    //     if(idx==n) return 0;
    //     //Recurrence;
    //     if(dp[idx][buy]!=-1) return dp[idx][buy];
    //     int profit = 0;
    //     if(buy==1) {
    //         profit = max(
    //             -prices[idx] + fn(idx+1, 0, prices, n, fee, dp),
    //              0 + fn(idx+1, 1, prices, n, fee, dp)
    //         );
    //     }
    //     else {
    //         profit = max(
    //             prices[idx] - fee + fn(idx+1, 1, prices, n, fee, dp),
    //             0 + fn(idx+1, 0, prices, n, fee, dp)
    //         );
    //     }
    //     return dp[idx][buy] = profit;
    // }
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();

        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(2, -1));
        // return fn(0, 1, prices, n, fee, dp);
        
        //Tabulation:
        // vector<vector<int>> dp(n+1, vector<int>(2, 0));
        // //Base case: not required, as its already filled correctly by the default values 0;
        // //Recurrence;
        // for(int i=n-1; i>=0; i--) {
        //     for(int buy=0; buy<=1; buy++) {
        //         int profit=0;
        //         if(buy==1) {
        //             profit = max(
        //                 -prices[i] + dp[i+1][0],
        //                 0 + dp[i+1][1]
        //             );
        //         }
        //         else {
        //             profit = max(
        //                 prices[i] - fee + dp[i+1][1],
        //                 0 + dp[i+1][0]
        //             );
        //         }
        //         dp[i][buy] = profit;
        //     }
        // }
        // return dp[0][1];

        //Tabulation + Space Optmization:
        vector<int> ahead(2, 0), cur(2, 0);
        //Base case: covered, reason same as above;
        //Recurrence;
        for(int i=n-1; i>=0; i--) {
            for(int buy=0; buy<=1; buy++) {
                int profit = 0;
                if(buy==1) {
                    profit = max(
                        -prices[i] + ahead[0],
                        0 + ahead[1]
                    );
                }
                else {
                    profit = max(
                        prices[i] - fee + ahead[1],
                        0 + ahead[0]
                    );
                }
                cur[buy] = profit;
            }
            ahead = cur;
        }
        return ahead[1];
    }
};
```
---
#### **DP on Longest Increasing Subsequence(LIS)**

[Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)
```c++
class Solution {
public:
    // int fn(int idx, int prev_idx, vector<int> &nums, int n,
    // vector<vector<int>> &dp) {
    //     //Base case;
    //     if(idx==n) return 0;
    //     if(dp[idx][prev_idx+1]!=-1) return dp[idx][prev_idx+1];
    //     //Recurrence;
    //     int not_take_len = 0 + fn(idx+1, prev_idx, nums, n, dp); //Not Take case
    //     int take_len = 0;
    //     if(prev_idx==-1 || nums[idx]>nums[prev_idx]) { //Take case
    //         take_len = 1 + fn(idx+1, idx, nums, n, dp);
    //     }
    //     return dp[idx][prev_idx+1] = max(not_take_len, take_len);
    // }
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();

        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(n+1, -1));
        // return fn(0, -1, nums, n, dp);

        //Tabulation:
        // vector<vector<int>> dp(n+1, vector<int>(n+1, 0));
        // //Base case: not required, already covered correctly by default values;
        // //Recurrence;
        // for(int idx=n-1; idx>=0; idx--) {
        //     for(int prev_idx = idx-1; prev_idx>=-1; prev_idx--) {
        //         //not take case;
        //         int not_take_len = 0 + dp[idx+1][prev_idx+1];
        //         //take case;
        //         int take_len = 0;
        //         if(prev_idx==-1 || nums[idx]>nums[prev_idx]) {
        //             take_len = 1 + dp[idx+1][idx+1];
        //         }
        //         dp[idx][prev_idx+1] = max(not_take_len, take_len);
        //     }
        // }
        // return dp[0][-1+1];

        //Tabulation + Space Optmization:
        vector<int> next(n+1, 0), cur(n+1, 0);
        //Base case: covered, reason same as above;
        //Recurrence;
        for(int idx=n-1; idx>=0; idx--) {
            for(int prev_idx=idx-1; prev_idx>=-1; prev_idx--) {
                //not take case;
                int not_take_len = 0 + next[prev_idx+1];
                // take case;
                int take_len = 0;
                if(prev_idx==-1 || nums[idx]>nums[prev_idx]) {
                    take_len = 1 + next[idx+1];
                }
                cur[prev_idx+1] = max(not_take_len, take_len);
            }
            next = cur;
        }
        return next[-1+1];
    }
};
```
[Print Longest Increasing Subsequence](https://www.geeksforgeeks.org/problems/printing-longest-increasing-subsequence/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=printing-longest-increasing-subsequence)
```c++
//{ Driver Code Starts
#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends
class Solution {
  public:
    vector<int> longestIncreasingSubsequence(int n, vector<int>& nums) {
        //Algorithmic method to first find the lenght of LIS (TUF - Striver);
        vector<int> dp(n, 1), hash(n, 0);
        int lis = 0;
        int last_idx=0;
        for(int idx=1; idx<n; idx++) {
            hash[idx] = idx;
            for(int prev_idx = 0; prev_idx<idx; prev_idx++) {
                if(nums[idx]>nums[prev_idx] && (1 + dp[prev_idx] > dp[idx])) {
                    dp[idx] = 1 + dp[prev_idx];
                    hash[idx] = prev_idx;
                }
            }
            if(dp[idx]>lis) {
                last_idx = idx;
                lis = dp[idx];
            }
        }
        //cout<<lis<<endl;
        
        vector<int> ans;
        ans.push_back(nums[last_idx]);
        while(hash[last_idx]!=last_idx) {
            last_idx = hash[last_idx];
            ans.push_back(nums[last_idx]);
        }
        reverse(ans.begin(), ans.end());
        return ans; 
    }
};
```
[Longest Increasing Subsequence](https://www.geeksforgeeks.org/problems/longest-increasing-subsequence-1587115620/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=longest-increasing-subsequence)
```c++
//{ Driver Code Starts
#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends


class Solution {
  public:
    // Function to find length of longest increasing subsequence.
    int lis(vector<int>& arr) {
        //Algorithmic method - Tabulation (TUF - Striver);
        int n = arr.size();
        // int lis = 0;
        // vector<int> dp(n, 1);
        // for(int idx=0; idx<n; idx++) {
        //     for(int prev_idx=0; prev_idx<idx; prev_idx++) {
        //         if(arr[idx]>arr[prev_idx]) {
        //             dp[idx] = max(dp[idx], 1 + dp[prev_idx]);
        //         }
        //     }
        //     lis = max(lis, dp[idx]);
        // }
        // return lis;
        
        //Binary Search Method (The length signifies the LIS);
        vector<int> tmp;
        tmp.push_back(arr[0]);
        int lis_len = 1;
        for(int i=1; i<n; i++) {
            if(arr[i]>tmp.back()) {
                tmp.push_back(arr[i]);
                lis_len++;
            }
            else {
                int idx = lower_bound(tmp.begin(), tmp.end(), arr[i]) - tmp.begin();
                tmp[idx] = arr[i];
            }
        }
        return lis_len;
    }
};
```
[Largest Divisible Subset](https://leetcode.com/problems/largest-divisible-subset/)
```c++
class Solution {
public:
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        int n = nums.size();
        // Via the LIS approach;
        sort(nums.begin(), nums.end());
        vector<int> dp(n, 1), hash(n);
        int lis_len = 0, last_idx = 0;
        for(int idx=0; idx<n; idx++) {
            hash[idx] = idx;
            for(int prev_idx=0; prev_idx<idx; prev_idx++) {
                if(nums[idx]%nums[prev_idx]==0 && (1+dp[prev_idx]>dp[idx])) {
                    dp[idx] = 1+dp[prev_idx];
                    hash[idx] = prev_idx;
                }
            }
            if(dp[idx]>lis_len) {
                lis_len = dp[idx];
                last_idx = idx;
            }
        }
        //cout<<lis_len<<endl;
        vector<int> ans;
        ans.push_back(nums[last_idx]);
        while(hash[last_idx]!=last_idx) {
            last_idx = hash[last_idx];
            ans.push_back(nums[last_idx]);
        }
        return ans;
    }
};
```
[Longest String Chain](https://leetcode.com/problems/longest-string-chain/)
```c++
class Solution {
public:
    static bool cmp(string &s1, string &s2) {
        return s1.size() < s2.size();
    }
    bool checkOrder(string &s1, string &s2) {
        int first=0, second=0;
        if(s1.size() != s2.size()+1) return false;
        while(first<s1.size()) {
            if(second<s2.size() && s1[first]==s2[second]) {
                first++;
                second++;
            }
            else {
                first++;
            }
        }
        if(first==s1.size() && second==s2.size()) {
            return true;
        }
        return false;
    }
    int longestStrChain(vector<string>& words) {
        int n = words.size();
        sort(words.begin(), words.end(), cmp);
        //Modification of LIS code;
        vector<int> dp(n, 1);
        int maxi = 0;
        for(int i=0; i<n; i++) {
            for(int j=0; j<i; j++) {
                if(checkOrder(words[i], words[j]) && (dp[j]+1>dp[i])) {
                    dp[i] = dp[j] + 1;
                }
            }
            maxi = max(maxi, dp[i]);
        }
        return maxi;
    }
};
```
[Longest Bitonic subsequence](https://www.geeksforgeeks.org/problems/longest-bitonic-subsequence0824/1)
```c++
//{ Driver Code Starts
#include <bits/stdc++.h>
using namespace std;

class Array {
  public:
    template <class T>
    static void input(vector<T> &A, int n) {
        for (int i = 0; i < n; i++) {
            scanf("%d ", &A[i]);
        }
    }

    template <class T>
    static void print(vector<T> &A) {
        for (int i = 0; i < A.size(); i++) {
            cout << A[i] << " ";
        }
        cout << endl;
    }
};


// } Driver Code Ends

class Solution {
  public:
    int LongestBitonicSequence(int n, vector<int> &nums) {
        vector<int> dp1(n, 1), dp2(n, 1);
        //Modification of LIS - First take for increasing
        // and then take for decreasing order. 
        //dp1[i] gives the LIS up till index i from left to right
        //dp2[i] gives the LIS up till index i from right to left
        //If you combine dp1[i] + dp2[i] and take the common
        //element of i(which is taken twice into account),
        //we get our LBS
        
        //Seeing left to right
        int m1=0;
        for(int i=0; i<n; i++) {
            for(int j=0; j<i; j++) {
                if(nums[i]>nums[j] && (dp1[j]+1 > dp1[i])) {
                    dp1[i] = dp1[j]+1;
                }
            }
            m1=max(m1, dp1[i]);
        }
        //Seeing right to left
        //Calculating the LBS here itself, instead of looping it 
        //separately again;
        int LBS = 0;
        int m2=0;
        for(int i=n-1; i>=0; i--) {
            for(int j=n-1; j>i; j--) {
                if(nums[i] > nums[j] && (dp2[j]+1 > dp2[i])) {
                    dp2[i] = dp2[j] + 1;
                }
            }
            m2=max(m2, dp2[i]);
        }
        
        for(int i=0; i<n; i++) {
            if(dp1[i]>1 && dp2[i]>1) {
                LBS = max(LBS, dp1[i]+dp2[i]-1);
            }
        }
        return LBS;
    }
};
```
[Number of Longest Increasing Subsequence](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)
```c++
class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1), cnt(n, 1);
        int lis = 0;
        for(int i=0; i<n; i++) {
            for(int j=0; j<i; j++) {
                if(nums[i] > nums[j] && (dp[j]+1 > dp[i])) {
                    dp[i] = dp[j]+1;
                    cnt[i] = cnt[j];
                }
                else if(nums[i] > nums[j] && (dp[j]+1 == dp[i])) {
                    cnt[i] += cnt[j];
                }
            }
            lis = max(lis, dp[i]);
        }
        int nlis = 0;
        for(int i=0; i<n;i++) {
            if(dp[i]==lis) nlis+=cnt[i];
        }
        return nlis;
    }
};
```
---
#### **MCM DP | Partition DP**

[Matrix Chain Multiplication](https://www.geeksforgeeks.org/problems/matrix-chain-multiplication0303/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=matrix-chain-multiplication)
```c++
//{ Driver Code Starts
#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends
// User function Template for C++

class Solution {
  public:
    // int fn(int i, int j, vector<int> & arr, vector<vector<int>> &dp) {
    //     //Base case;
    //     if(i==j) return 0;
    //     //Partitions;
    //     int mini = 1e9;
    //     int steps=0;
    //     if(dp[i][j]!=-1) return dp[i][j];
    //     for(int k=i; k<=j-1; k++) {
    //         steps = arr[i-1]*arr[k]*arr[j] + fn(i, k, arr, dp)
    //             + fn(k+1, j, arr, dp);
    //         mini = min(mini, steps);
    //     }
    //     return dp[i][j] = mini;
    // }
    int matrixMultiplication(vector<int> &arr) {
        int n = arr.size();
        //Memoization:
        // vector<vector<int>> dp(n, vector<int>(n, -1));
        // return fn(1, n-1, arr, dp);
        
        //Tabulation:
        vector<vector<int>> dp(n, vector<int>(n, 0));
        //Base case: not required as its correctly populated with default 
        //value, but again mentioning it for clarity of conversion from
        //memoization to tabulation;
        for(int i=0; i<n; i++) {
            dp[i][i] = 0;
        }
        //Recurrence;
        for(int i=n-1; i>=0; i--) {
            for(int j=i+1; j<n; j++) {
                int mini = 1e9;
                int steps = 0;
                for(int k=i; k<=j-1; k++) {
                    steps = arr[i-1]*arr[k]*arr[j] + dp[i][k] + dp[k+1][j];
                    mini = min(mini, steps);
                }
                dp[i][j] = mini;
            }
        }
        return dp[1][n-1];
        
        //Tabulation + Space Optimization: Not Applicable, as we don't have
        //uniformity in index calculations of the dp table;
    }
};
```
[Minimum Cost to Cut a Stick](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/)
```c++
class Solution {
public:
    // int fn(int i, int j, vector<int> &cuts,
    //     vector<vector<int>> &dp) {
    //     //Base case;
    //     if(i>j) return 0;
    //     //Recurrence;
    //     if(dp[i][j]!=-1) return dp[i][j];
    //     int mini = 1e9;
    //     int cost = 0;
    //     for(int ind=i; ind<=j; ind++) {
    //         cost = (cuts[j+1] - cuts[i-1]) + fn(i, ind-1, cuts, dp)
    //             + fn(ind+1, j, cuts, dp);
    //         mini = min(mini, cost);
    //     }
    //     return dp[i][j] = mini;
    // }
    int minCost(int n, vector<int>& cuts) {
        int c = cuts.size();
        //Adding 0 and n(stick length) for easier calculation;
        cuts.push_back(n);
        cuts.insert(cuts.begin(), 0);
        sort(cuts.begin(), cuts.end());

        //Memoization:
        // vector<vector<int>> dp(c+1, vector<int>(c+1, -1));
        // return fn(1, c, cuts, dp);

        //Tabulation:
        vector<vector<int>> dp(c+2, vector<int>(c+2, 0));
        //Base case: already populated with default values 0;
        //Recurrence;
        for(int i=c; i>=1; i--) {
            for(int j=i; j<=c; j++) {
                //if(i>j) continue;
                int mini = 1e9;
                int cost = 0;
                for(int ind=i; ind<=j; ind++) {
                    cost = (cuts[j+1] - cuts[i-1]) + dp[i][ind-1]
                        + dp[ind+1][j];
                    mini = min(mini, cost);
                }
                dp[i][j] = mini;
            }
        }
        return dp[1][c];
    }
};
```
[Burst Balloons](https://leetcode.com/problems/burst-balloons/)
```c++
class Solution {
public:
    // int fn(int i, int j, vector<int> &nums, vector<vector<int>> &dp) {
    //     //Base case;
    //     if(i>j) return 0;
    //     //Recurrence;
    //     if(dp[i][j]!=-1) return dp[i][j];
    //     int maxi = INT_MIN;
    //     int cost = 0;
    //     for(int ind=i; ind<=j; ind++) {
    //         cost = nums[i-1]*nums[ind]*nums[j+1] + fn(i, ind-1, nums, dp) 
    //             + fn(ind+1, j, nums, dp);
    //         maxi = max(cost, maxi);
    //     }
    //     return dp[i][j] = maxi;
    // }
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        nums.push_back(1);
        nums.insert(nums.begin(), 1);

        //Memoization:
        // vector<vector<int>> dp(n+1, vector<int>(n+1, -1));
        // return fn(1, n, nums, dp);

        //Tabulation:
        vector<vector<int>> dp(n+2, vector<int>(n+1, 0));
        //Base case: already covered with default values 0, Plus a small
        //addition will the made in the looping;
        //Recurrence;
        for(int i=n; i>=1; i--) {
            for(int j=1; j<=n; j++) {
                //Base case;
                if(i>j) continue;
                int cost = 0;
                int maxi = INT_MIN;
                for(int ind=i; ind<=j; ind++) {
                    cost = nums[i-1]*nums[ind]*nums[j+1] + dp[i][ind-1]
                        + dp[ind+1][j];
                    maxi = max(cost, maxi);
                }
                dp[i][j] = maxi;
            }
        }
        return dp[1][n];
    }
};
```
[Boolean Evaluation](https://www.naukri.com/code360/problems/boolean-evaluation_1214650?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf)
```c++
#define ll long long
int mod = 1000000007;
// long long fn(int i, int j, int isTrue, string &exp, 
//     vector<vector<vector<ll>>> &dp) {
//     //Base cases;
//     if(i>j) return 0; //no partition
//     if(i==j) {
//         if(isTrue) return exp[i]=='T';
//         else return exp[i]=='F';
//     }
//     //Recurrence;
//     if(dp[i][j][isTrue]!=-1) return dp[i][j][isTrue];
//     ll ways = 0;
//     //do partitions on the operator positions, which is from
//     //i+1 to j-1 on increments of two;
//     for(int ind=i+1; ind<=j-1; ind=ind+2) {
//         ll lT = fn(i, ind-1, 1, exp, dp);
//         ll lF = fn(i, ind-1, 0, exp, dp);
//         ll rT = fn(ind+1, j, 1, exp, dp);
//         ll rF = fn(ind+1, j, 0, exp, dp);

//         //calculating ways based on the operator;
//         if(exp[ind]=='&') {
//             if(isTrue) {
//                 ways = (ways + (lT*rT)%mod)%mod;
//             }
//             else {
//                 ways = (ways + (lT*rF)%mod + (lF*rT)%mod + (lF*rF)%mod 
//                 )%mod;
//             }
//         }
//         else if(exp[ind]=='|') {
//             if(isTrue) {
//                 ways = (ways + (lT*rT)%mod + (lT*rF)%mod + (lF*rT)%mod
//                 )%mod;
//             }
//             else {
//                 ways = (ways + (lF*rF)%mod)%mod;
//             }
//         }
//         else {
//             if(isTrue) {
//                 ways = (ways + (lT*rF)%mod + (lF*rT)%mod
//                 )%mod;
//             }
//             else {
//                 ways = (ways + (lF*rF)%mod + (lT*rT)%mod
//                 )%mod;
//             }
//         }
//     }
//     return dp[i][j][isTrue] = ways%mod;
// }
int evaluateExp(string & exp) {
    int n = exp.size();

    //Memoization:
    //vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(n, vector<ll>(2, -1)));
    //return (int)fn(0, n-1, 1, exp, dp);

    //Tabulation:
    vector<vector<vector<ll>>> dp(n+1, vector<vector<ll>>(n+1, vector<ll>(2, 0)));
    //Base case;
    for(int i=0; i<n; i++) {
        
    }
    //Recurrence;
    for(int i=n-1; i>=0; i--) {
        for(int j=0; j<=n-1; j++) {
            if (i>j) continue;
            else if(i==j) {
                dp[i][i][1] = (exp[i]=='T');
                dp[i][i][0] = (exp[i]=='F');
            }
            else {
                ll waysT = 0;
                ll waysF = 0;
                //do partitions on the operator positions, which is from
                //i+1 to j-1 on increments of two;
                for(int ind=i+1; ind<=j-1; ind=ind+2) {
                    ll lT = dp[i][ind-1][1]; 
                    ll lF = dp[i][ind-1][0]; 
                    ll rT = dp[ind+1][j][1]; 
                    ll rF = dp[ind+1][j][0]; 

                    //calculating ways based on the operator;
                    if(exp[ind]=='&') {
                        waysT = (waysT + (lT*rT)%mod)%mod;

                        waysF = (waysF + (lT*rF)%mod + (lF*rT)%mod + (lF*rF)%mod 
                        )%mod;
                    }
                    else if(exp[ind]=='|') {
                        waysT = (waysT + (lT*rT)%mod + (lT*rF)%mod + (lF*rT)%mod
                        )%mod;


                        waysF = (waysF + (lF*rF)%mod)%mod;
                    } else {
                        waysT = (waysT + (lT * rF) % mod + (lF * rT) % mod) % mod;

                        waysF = (waysF + (lF * rF) % mod + (lT * rT) % mod) % mod;
                    }
                }
                dp[i][j][1] = waysT % mod;
                dp[i][j][0] = waysF % mod;
            }
        }
    }
    return dp[0][n-1][1];
}
```
[Palindrome Partitioning II](https://leetcode.com/problems/palindrome-partitioning-ii/)
```c++
class Solution {
public:
    int isPalindrome(int i, int j, string &s) {
        while(i<j) {
            if(s[i]!=s[j]) return false;
            i++;
            j--;
        }
        return true;
    }
    // int fn(int ind, int n, string &s, vector<int> &dp) {
    //     //Base case;
    //     if(ind==n) return 0;
    //     //Recurrence;
    //     if(dp[ind]!=-1) return dp[ind];
    //     int mini = INT_MAX;
    //     int cost = 0;
    //     for(int j = ind; j<n; j++) {
    //         if(isPalindrome(ind, j, s)) {
    //             cost = 1 + fn(j+1, n, s, dp);
    //             mini = min(mini, cost);
    //         }
    //     }
    //     return dp[ind] = mini;
    // }
    int minCut(string s) {
        //Front Partition Approach;
        int n = s.size();
        //Memoization:
        // vector<int> dp(n, -1);
        // return fn(0, n, s, dp)-1;      

        //Tabulation:
        vector<int> dp(n+1, 0);
        //Base case:
        dp[n] = 0;
        //Recurrence;
        for(int ind=n-1; ind>=0; ind--) {
            int mini = INT_MAX;
            int cost = 0;
            for(int j = ind; j<n; j++) {
                if(isPalindrome(ind, j, s)) {
                    cost = 1 + dp[j+1];
                    mini = min(mini, cost);
                }
            }
            dp[ind] = mini;
        }
        return dp[0]-1;  
    }
};
```
[Partition Array for Maximum Sum](https://leetcode.com/problems/partition-array-for-maximum-sum/)
```c++
class Solution {
public:
    // int fn(int ind, int n, vector<int> &arr, int k, vector<int> &dp) {
    //     //Base case;
    //     if(ind==n) return 0;
    //     //Recurrence;
    //     if(dp[ind]!=-1) return dp[ind];
    //     int maxElement = INT_MIN;
    //     int cost = 0;
    //     int len = 0;
    //     int maxAns = INT_MIN;
    //     for(int j = ind; j<min(ind+k, n); j++) {
    //         len++;
    //         maxElement = max(maxElement, arr[j]);
    //         cost = len*maxElement + fn(j+1, n, arr, k, dp);
    //         maxAns = max(cost, maxAns);
    //     }
    //     return dp[ind] = maxAns;
    // }
    int maxSumAfterPartitioning(vector<int>& arr, int k) {
        //Front Partition Approach;
        int n = arr.size();
        //Memoization:
        // vector<int> dp(n, -1);
        // return fn(0, n, arr, k, dp);

        //Tabulation:
        vector<int> dp(n+1, 0);
        //Base case;
        dp[n] = 0;
        //Recurrence;
        for(int ind=n-1; ind>=0; ind--) {
            int maxElement = INT_MIN;
            int cost = 0;
            int len = 0;
            int maxAns = 0;
            for(int j = ind; j<min(ind+k, n); j++) {
                len++;
                maxElement = max(maxElement, arr[j]);
                cost = len*maxElement + dp[j+1];
                maxAns = max(maxAns, cost);
            }
            dp[ind] = maxAns;
        }
        return dp[0];        
    }
};
```
---
#### **DP on Squares**

[Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/)
```c++
class Solution {
public:
    int largeHist(vector<int> &heights) {
        //To understand this(if you forgot how it works), refer to that
        //problem. Comments are added to it.
        int n = heights.size();
        stack<int> st;
        vector<int> left(n, 0), right(n, 0);

        //1st pass for left;
        for(int i=0; i<n; i++) {
            while(!st.empty() && heights[st.top()] >= heights[i]) {
                st.pop();
            }
            if(st.empty()) left[i] = 0;
            else left[i] = st.top()+1;

            st.push(i);
        }

        //Clear the stack before using it for next pass;
        while(!st.empty()) st.pop();

        //2nd pass for right;
        for(int i=n-1; i>=0; i--) {
            while(!st.empty() && heights[st.top()] >= heights[i]) {
                st.pop();
            }
            if(st.empty()) right[i] = n-1;
            else right[i] = st.top()-1;

            st.push(i);
        }

        //Print - Debug;
        for(int i=0; i<n; i++) {
            cout<<left[i]<<":"<<right[i]<<endl;
            cout<<heights[i]<<endl;
        }

        //Calucate the maxArea using the right and left vector values;
        int maxArea = INT_MIN;
        for(int i=0; i<n; i++) {
            maxArea = max(maxArea, (right[i]-left[i]+1)*heights[i]);
        }
        cout<<endl;
        return maxArea;
    }
    int maximalRectangle(vector<vector<char>>& matrix) {
        //Using a concept and approach from the problem of 
        //Largest rectangle in a Histogram to build this solution;

        int n = matrix.size();
        int m = matrix[0].size();
        vector<int> heights(m, 0);
        int maxRect = INT_MIN;
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                if(i==0) {
                    if(matrix[i][j]=='1') {
                        heights[j] = 1;
                    }
                    else {
                        heights[j] = 0;
                    }
                }
                else {
                    if(matrix[i][j]=='1') {
                        heights[j] +=1;
                    }
                    else {
                        heights[j]=0;
                    }
                }
            }
            int maxHistArea = largeHist(heights);
            maxRect = max(maxRect, maxHistArea);
        }
        return maxRect;
    }
};
```
[Count Square Submatrices with All Ones](https://leetcode.com/problems/count-square-submatrices-with-all-ones/)
```c++
class Solution {
public:
    int countSquares(vector<vector<int>>& matrix) {
        //Directyl via Tabulation method:
        int n = matrix.size();
        int m = matrix[0].size();
        vector<vector<int>> dp(n, vector<int>(m, 0));
        int sum=0;

        for(int j=0; j<m; j++) {
            dp[0][j] = matrix[0][j];
            sum+=dp[0][j];
        }
        for(int i=1; i<n; i++) {
            dp[i][0] = matrix[i][0];
            sum+=dp[i][0];
        }
        cout<<sum;
        for(int i=1; i<n; i++) {
            for(int j=1; j<m; j++) {
                if(matrix[i][j]==1) {
                    dp[i][j] = min(dp[i-1][j], 
                        min(dp[i][j-1], dp[i-1][j-1])) + 1;
                }
                else {
                    dp[i][j] = 0;
                }
                sum+=dp[i][j];
            }
        }
        return sum;
    }
};
```
---

#### **General Pattern for DP**
##### **Memoization:**

##### **Tabulation:**

##### **Tabulation + Space Optimization**

##### **Wrapping up**
Thanks!