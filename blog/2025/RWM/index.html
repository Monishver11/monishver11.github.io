<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="9O0EoPaLhgFjSIvAkDDoQK0gr49C2Wuxtgl3c0bXObM"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Randomized Weighted Majority Algorithm | Monishver Chandrasekaran </title> <meta name="author" content="Monishver Chandrasekaran"> <meta name="description" content="Learn how the Randomized Weighted Majority (RWM) Algorithm leverages probabilistic prediction to minimize regret and defend against adversarial strategies in online learning environments."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/logo.png?b337fdf3fe456a8da16aab16e9a00f8c"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://monishver11.github.io/blog/2025/RWM/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class=" "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm sticky-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Monishver</span> Chandrasekaran </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume </a> </li> <li class="nav-item "> <a class="nav-link" href="/thoughts/">Thoughts </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title" style="font-weight: 400;">Randomized Weighted Majority Algorithm</h1> <p class="post-meta"> Created in January 29, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/ml"> <i class="fa-solid fa-hashtag fa-sm"></i> ML</a>   <a href="/blog/tag/math"> <i class="fa-solid fa-hashtag fa-sm"></i> Math</a>   ·   <a href="/blog/category/adv-ml-nyu"> <i class="fa-solid fa-tag fa-sm"></i> ADV-ML-NYU</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>The <strong>Randomized Weighted Majority (RWM) algorithm</strong> is an extension of the <strong>deterministic Weighted Majority (WM) algorithm</strong>, designed to overcome its limitations in adversarial settings, particularly in the <strong>zero-one loss</strong> scenario. This post explores why the deterministic approach struggles, how randomization helps, and what makes the RWM algorithm effective.</p> <h4 id="problem-with-the-deterministic-wm-algorithm"><strong>Problem with the Deterministic WM Algorithm</strong></h4> <p>The <strong>deterministic Weighted Majority (WM) algorithm</strong> operates by maintaining a set of experts, assigning them weights, and updating these weights based on their correctness. However, this approach suffers from <strong>high regret</strong> in adversarial settings.</p> <ul> <li> <p><strong>Regret in adversarial settings</strong><br> No deterministic algorithm can achieve a <strong>sublinear regret</strong> of \(R_T = o(T)\) for all possible sequences under zero-one loss.</p> </li> <li> <p><strong>Worst-case scenario leading to linear regret</strong><br> If the adversary knows the algorithm’s strategy, it can force it to make mistakes at every step.</p> <ul> <li>Suppose we have two experts: one always predicts <strong>0</strong>, the other always predicts <strong>1</strong>.</li> <li>If the best expert is correct <strong>only half the time</strong>, it makes at most <strong>\(T/2\)</strong> mistakes.</li> <li>The regret is defined as: \(R_T = m_T - m_T^*\)<br> where: <ul> <li>\(m_T\) is the number of mistakes made by the algorithm.</li> <li>\(m_T^*\) is the number of mistakes made by the best expert.</li> </ul> </li> </ul> <p>Since \(m_T^* \leq T/2\), the regret in the worst case is at least: \(R_T \geq T/2\) which grows <strong>linearly</strong> with \(T\).</p> </li> </ul> <h4 id="the-randomized-weighted-majority-algorithm"><strong>The Randomized Weighted Majority Algorithm</strong></h4> <p>To address this issue, the <strong>Randomized Weighted Majority (RWM)</strong> algorithm introduces <strong>randomness</strong> into the decision-making process. Instead of deterministically following the highest-weighted expert, it assigns a <strong>probabilistic prediction</strong> based on expert weights.</p> <h5 id="key-idea-behind-rwm"><strong>Key Idea Behind RWM</strong></h5> <ul> <li>Instead of picking the expert with the highest weight <strong>deterministically</strong>, the algorithm selects predictions <strong>probabilistically</strong>, based on expert weights.</li> <li>Experts that have made fewer mistakes are given <strong>higher weights</strong>, making them more likely to be followed.</li> <li>This <strong>randomization prevents the adversary</strong> from forcing the algorithm to always make the same mistakes.</li> </ul> <h5 id="benefits-of-randomization"><strong>Benefits of Randomization</strong></h5> <ul> <li> <p><strong>Sublinear regret in adversarial settings</strong><br> Unlike the deterministic approach, RWM can achieve: \(R_T = O(\sqrt{T})\) making it significantly better in the long run.</p> </li> <li> <p><strong>More balanced decision-making</strong><br> By updating expert weights probabilistically, the algorithm avoids overly trusting any one expert too soon.</p> </li> </ul> <h4 id="the-randomized-weighted-majority-algorithm-step-by-step"><strong>The Randomized Weighted Majority Algorithm: Step-by-Step</strong></h4> <p>The algorithm follows these steps:</p> <ol> <li> <strong>Initialize Weights:</strong> Each expert starts with an equal weight of <strong>1</strong>.</li> <li> <strong>Compute Probabilities:</strong> The probability of selecting an expert is proportional to its weight.</li> <li> <strong>Make a Prediction:</strong> Instead of following a single expert, the algorithm chooses its prediction probabilistically.</li> <li> <strong>Update Weights:</strong> Experts that make mistakes have their weights <strong>decreased</strong> by a factor \(\beta\), where \(0 &lt; \beta &lt; 1\).</li> </ol> <p><strong><mark>Pseudocode:</mark></strong></p> \[\begin{array}{l} \textbf{Randomized-Weighted-Majority} \ (N) \\[5pt] \quad 1. \quad \textbf{for } i \gets 1 \text{ to } N \textbf{ do} \\ \quad 2. \quad \quad w_{1,i} \gets 1 \\ \quad 3. \quad \quad p_{1,i} \gets \frac{1}{N} \\[5pt] \quad 4. \quad \textbf{for } t \gets 1 \text{ to } T \textbf{ do} \\ \quad 5. \quad \quad \textbf{Receive } l_t \\ \quad 6. \quad \quad \textbf{for } i \gets 1 \text{ to } N \textbf{ do} \\ \quad 7. \quad \quad \quad \textbf{if } (l_{t,i} = 1) \textbf{ then} \\ \quad 8. \quad \quad \quad \quad w_{t+1,i} \gets \beta w_{t,i} \\ \quad 9. \quad \quad \quad \textbf{else} \\ \quad10. \quad \quad \quad \quad w_{t+1,i} \gets w_{t,i} \\[5pt] \quad11. \quad \quad W_{t+1} \gets \sum_{i=1}^{N} w_{t+1,i} \\[5pt] \quad12. \quad \quad \textbf{for } i \gets 1 \text{ to } N \textbf{ do} \\ \quad13. \quad \quad \quad p_{t+1,i} \gets w_{t+1,i} / W_{t+1} \\[5pt] \quad14. \quad \textbf{return } \mathbf{w}_{T+1} \end{array}\] <p>At this point, we’ve introduced the RWM algorithm, but a key question remains:</p> <blockquote> <p>How does randomization <strong>actually prevent</strong> the algorithm from making repeated mistakes, and how is the probabilistic selection <strong>used effectively</strong>?</p> </blockquote> <p>We’ll dive into this in the next section.</p> <hr> <h4 id="how-randomization-prevents-repeated-mistakes"><strong>How Randomization Prevents Repeated Mistakes</strong></h4> <p>The <strong>Randomized Weighted Majority (RWM)</strong> algorithm prevents repeated mistakes in adversarial settings by making predictions <strong>probabilistically based on expert weights</strong>. Here’s how this works step by step:</p> <p><strong>1. Maintaining Expert Weights</strong></p> <ul> <li>We assign an initial weight to each expert, typically \(w_i^{(1)} = 1\) for all experts \(i\).</li> <li>Over time, we <strong>update the weights</strong> of experts based on their performance, penalizing those who make mistakes.</li> </ul> <p><strong>2. Making Probabilistic Predictions</strong></p> <ul> <li>Instead of deterministically following the best expert (which an adversary could exploit), RWM <strong>randomly selects a prediction</strong> based on the current expert weights.</li> <li>The probability of choosing a particular expert’s prediction is proportional to their weight: \(P(y_t = y_i) = \frac{w_i^{(t)}}{\sum_{j=1}^{N} w_j^{(t)}}\)<br> where \(w_i^{(t)}\) is the weight of expert \(i\) at time \(t\).</li> <li>This means that if an expert has a high weight (i.e., has made fewer mistakes), their prediction is <strong>more likely</strong> to be chosen, but not always.</li> <li>If an adversary tries to force mistakes by targeting a specific deterministic strategy, the randomization ensures that the algorithm <strong>does not always follow a single pattern</strong>, making it harder for the adversary to exploit.</li> </ul> <p><strong>3. Weight Update Rule</strong></p> <ul> <li>After making a prediction, the algorithm observes the true outcome \(y_t\).</li> <li>The weights of experts who made mistakes are <strong>exponentially decreased</strong> using a multiplicative update rule: \(w_i^{(t+1)} = w_i^{(t)} \cdot \beta^{\ell_i^{(t)}}\)<br> where: <ul> <li>\(\ell_i^{(t)}\) is the loss (1 if the expert made a mistake, 0 otherwise),</li> <li>\(\beta \in (0,1)\) is a parameter that determines how aggressively the weights are updated.</li> </ul> </li> <li>This ensures that over time, experts who consistently make mistakes lose influence, while those with good predictions gain more say in future predictions.</li> </ul> <p><strong>4. Why This Prevents Repeated Mistakes</strong></p> <ul> <li>Since the algorithm chooses predictions probabilistically, it does not <strong>consistently</strong> make the same mistakes like a deterministic algorithm would.</li> <li>Even if an adversary tries to construct a sequence that forces a mistake, RWM’s randomization means that <strong>the same incorrect choice won’t always be made</strong>.</li> <li>Moreover, since weights adjust dynamically, experts who perform better in the long run <strong>gradually dominate</strong> the prediction process.</li> </ul> <h5 id="takeaways"><strong><mark>Takeaways:</mark></strong></h5> <ul> <li> <strong>Randomization prevents predictable failures</strong>: The algorithm does not follow a fixed pattern, making it harder for an adversary to force mistakes.</li> <li> <strong>Probabilities favor better experts</strong>: Instead of blindly following one expert, the algorithm balances between exploration (randomization) and exploitation (favoring high-weight experts).</li> <li> <strong>Weights adjust over time</strong>: Poor-performing experts lose influence, ensuring the algorithm improves as more data is observed.</li> </ul> <p>By incorporating randomness, the <strong>Randomized Weighted Majority Algorithm</strong> provides a <strong>powerful and adaptive approach</strong> to online learning, making it a fundamental tool in adversarial learning settings.</p> <hr> <p>Here’s an analogy to make the <strong>Randomized Weighted Majority (RWM) algorithm</strong> more intuitive:</p> <p>Imagine you are in a <strong>new city</strong> for an extended stay, and you have to decide <strong>where to eat dinner every night</strong>. There are multiple restaurants (experts), and each night, you choose one based on your past experiences.</p> <p><strong>1. Initial Equal Preference (Assigning Weights)</strong></p> <p>At the start, you <strong>have no idea</strong> which restaurant is the best. So, you assign them equal preference:</p> <ul> <li>Restaurant A, B, and C all seem equally good, so you <strong>randomly pick one</strong>.</li> </ul> <p><strong>2. Evaluating Performance (Tracking Mistakes)</strong></p> <p>Each time you eat at a restaurant, you observe whether the meal was <strong>good</strong> or <strong>bad</strong>.</p> <ul> <li>If the meal was great, you <strong>trust the restaurant more</strong>.</li> <li>If it was terrible, you <strong>trust it less</strong>.</li> </ul> <p><strong>3. Adjusting Your Choices Over Time (Weight Updates)</strong></p> <p>Instead of always sticking to a single restaurant (which might backfire if it suddenly declines in quality), you <strong>adjust your preferences probabilistically</strong>:</p> <ul> <li>If <strong>Restaurant A</strong> has served consistently good food, you start <strong>choosing it more often</strong>, but you <strong>don’t completely ignore</strong> B and C.</li> <li>If <strong>Restaurant B</strong> has had a few bad meals, you reduce your visits there <strong>but still give it a chance occasionally</strong>.</li> </ul> <p><strong>4. Why Randomization Helps</strong></p> <p>Imagine there’s a <strong>food critic (the adversary)</strong> trying to ruin your dining experience.</p> <ul> <li>If you <strong>always follow a deterministic rule</strong> (e.g., always picking the currently best restaurant), the critic can <strong>sabotage your choices</strong>—perhaps by tipping off the restaurant to serve bad food only when you visit.</li> <li>However, by <strong>randomizing your choices</strong> (with a bias toward better restaurants), the critic <strong>can’t predict where you’ll go</strong>, making it much harder to force repeated bad experiences.</li> </ul> <p><strong>5. Long-Term Adaptation (Minimizing Regret)</strong></p> <p>Over time, bad restaurants get <strong>fewer chances</strong>, and good ones <strong>dominate your choices</strong>. But, because you <strong>never completely eliminate</strong> any option, you still have room to adjust if a once-bad restaurant improves.</p> <h5 id="mapping-back-to-rwm"><strong>Mapping Back to RWM</strong></h5> <ul> <li><strong>Restaurants = Experts</strong></li> <li><strong>Your decision = Algorithm’s prediction</strong></li> <li><strong>Good meal = Correct prediction (no loss)</strong></li> <li><strong>Bad meal = Mistake (loss)</strong></li> <li><strong>Reducing visits to bad restaurants = Lowering expert weights</strong></li> <li><strong>Randomly choosing where to eat = Making probabilistic predictions</strong></li> </ul> <p>By <strong>not always following the same pattern</strong>, you prevent predictable failures and <strong>gradually learn the best strategy</strong> while adapting to changes.</p> <hr> <h4 id="randomized-weighted-majority-algorithm-regret-bound-and-proof"><strong>Randomized Weighted Majority Algorithm: Regret Bound and Proof</strong></h4> <p>The main objective of the RWM algorithm is to minimize the <strong>regret</strong>, which is the difference between the cumulative loss of the algorithm and that of the best possible decision (in hindsight) over time.</p> <p>Now, we’ll dive into the <strong>regret bound</strong> for the RWM algorithm. Specifically, we’ll present a theorem that gives a strong guarantee on the regret \(R_T\) of the algorithm, and follow up with a proof that demonstrates the result.</p> <h5 id="setting--notations"><strong>Setting &amp; Notations</strong></h5> <p>At each round \(t \in [T]\), an online algorithm \(A\) selects a distribution \(p_t\) over the set of actions, receives a loss vector \(\mathbf{l}_t\), whose \(i\)-th component \(l_{t,i} \in [0, 1]\) is the loss associated with action \(i\), and incurs the expected loss:</p> \[L_t = \sum_{i=1}^{N} p_{t,i} l_{t,i}\] <p>The total loss incurred by the algorithm over \(T\) rounds is:</p> \[\mathcal{L}_T = \sum_{t=1}^{T} L_t\] <p>The total loss associated with action \(i\) is:</p> \[\mathcal{L}_{T,i} = \sum_{t=1}^{T} l_{t,i}\] <p>The minimal loss of a single action is denoted by:</p> \[\mathcal{L}_{\text{min}}^T = \min_{i \in A} \mathcal{L}_{T,i}\] <p>The regret \(R_T\) of the algorithm after \(T\) rounds is typically defined as the difference between the loss of the algorithm and that of the best single action:</p> \[R_T = \mathcal{L}_T - \mathcal{L}_{\text{min}}^T\] <p><strong>Note:</strong> Whenever you’re confused by the notations of \(L\) and \(\mathcal{L}\), refer to this.</p> <hr> <h5 id="rwm-regret-bound"><strong>RWM Regret Bound</strong></h5> <p>The following <strong>theorem</strong> provides a regret bound for the RWM algorithm, showing that the regret \(R_T\) is in \(O(\sqrt{T \log N})\), where \(T\) is the number of rounds, and \(N\) is the number of experts.</p> <p><strong>Theorem</strong> : Fix \(\beta \in [\frac{1}{2}, 1)\). Then, for any \(T \geq 1\), the loss of the algorithm \(\text{RWM}\) on any sequence of decisions can be bounded as follows:</p> \[\mathcal{L}_T \leq \frac{\log N}{1 - \beta} + (2 - \beta) \mathcal{L}^{\min}_T \tag{1}\] <p>In particular, for \(\beta = \max\left(\frac{1}{2}, 1 - \sqrt{\frac{\log N}{T}}\right)\), the loss can be further bounded as:</p> \[\mathcal{L}_T \leq \mathcal{L}^{\min}_T + 2 \sqrt{T \log N} \tag{2}\] <p>Here, \(\mathcal{L}_T\) is the total loss incurred by the algorithm till \(T\) rounds, and \(\mathcal{L}^{\min}_T\) is the minimal possible loss achievable by any expert till \(T\) rounds.</p> <hr> <h5 id="proof-outline-deriving-the-regret-bound"><strong>Proof Outline: Deriving the Regret Bound</strong></h5> <p>The proof of this result relies on analyzing the <strong>potential function</strong> \(W_t\), which represents the total weight assigned to the experts at each round \(t\). We derive upper and lower bounds for \(W_t\) and combine them to establish the regret bound.</p> <p>Let’s walk through the key steps of the proof.</p> <hr> <p><strong>Step 1: The Weight Update Rule</strong> The weight of expert \(i\) at round \(t+1\) is updated based on their incurred loss \(l_{t,i}\):</p> \[w_{t+1, i} = \begin{cases} w_{t, i} \cdot \beta, &amp; \text{if } l_{t, i} = 1 \\ w_{t, i}, &amp; \text{if } l_{t, i} = 0 \end{cases}\] <p>where \(\beta \in (0,1)\) is a fixed discount factor.</p> <p>The total weight at round \(t+1\) is then:</p> \[W_{t+1} = \sum_{i=1}^{N} w_{t+1, i}\] <hr> <p><strong>Step 2: Evolution of Total Weight</strong> Using the update rule, we can express \(W_{t+1}\) in terms of \(W_t\):</p> \[W_{t+1} = \sum_{i: l_{t,i} = 0} w_{t,i} + \beta \sum_{i: l_{t,i} = 1} w_{t,i}\] \[= W_t + (\beta - 1) \sum_{i: l_{t,i} = 1} w_{t,i}\] \[= W_t + (\beta - 1) W_t \sum_{i: l_{t,i} = 1} p_{t,i}\] \[= W_t + (\beta - 1) W_t L_t\] \[= W_t (1 - (1 - \beta) L_t)\] <hr> <p><strong>Note:</strong> If you’re unsure, refer to the items listed below, which should be used appropriately to achieve the desired result.</p> <p>Using the probability interpretation of the weights:</p> \[\sum_{i: l_{t,i}=1} w_{t,i} = W_t L_t,\] <p>where \(L_t\) is the expected loss at time \(t\):</p> \[L_t = \sum_{i=1}^{N} p_{t,i} l_{t,i}\] <p>Thus, we obtain:</p> \[W_{t+1} = W_t(1 - (1 - \beta) L_t)\] <hr> <p>By recursion, since \(W_1 = N\), we get:</p> \[W_{T+1} = N \prod_{t=1}^{T} (1 - (1 - \beta) L_t)\] <hr> <p><strong>Step 3: Lower Bound on \(W_{T+1}\)</strong> The minimum weight of any expert at round \(T+1\) satisfies:</p> \[W_{T+1} \geq \max_{i \in [N]} w_{T+1, i} = \beta^{\mathcal{L}_T^{\min}}\] <p>where \(\mathcal{L}_T^{\min}\) is the loss of the best expert.</p> <p>How did we arrive at this version?</p> <p>Each expert’s weight evolves according to the <strong>multiplicative update rule</strong>. If expert \(i\) incurs a loss \(l_{t,i}\) at round \(t\), its weight is updated as:</p> \[w_{t+1, i} = w_{t,i} \cdot \beta^{l_{t,i}}\] <p>where \(\beta \in (0,1]\) is the update factor.</p> <p>Define the <strong>best expert</strong> as the one with the <strong>minimum cumulative loss</strong> over \(T\) rounds. Let \(\mathcal{L}_T^{\min}\) denote this minimum loss:</p> \[\mathcal{L}_T^{\min} = \min_{i \in [N]} \sum_{t=1}^{T} l_{t,i}\] <p>For this best expert (say expert \(i^*\)), its weight after \(T\) rounds evolves as:</p> \[w_{T+1, i^*} = w_{1, i^*} \cdot \prod_{t=1}^{T} \beta^{l_{t,i^*}}\] <p>Since all experts start with an equal initial weight \(w_{1, i} = 1\) (assuming uniform initialization), we have:</p> \[w_{T+1, i^*} = \beta^{\mathcal{L}_T^{\min}}\] <p>Since the <strong>total weight</strong> at round \(T+1\) is at least the weight of the best expert, we get:</p> \[W_{T+1} = \sum_{i=1}^{N} w_{T+1, i} \geq w_{T+1, i^*} = \beta^{\mathcal{L}_T^{\min}}\] <p>Thus, the lower bound holds:</p> \[W_{T+1} \geq \beta^{\mathcal{L}_T^{\min}}\] <p>This ensures that the total weight does not shrink too fast, preserving a lower bound based on the best expert’s performance.</p> <hr> <p><strong>Step 4: Taking Logarithms</strong> Taking the logarithm of both bounds:</p> \[\log W_{T+1} = \log N + \sum_{t=1}^{T} \log (1 - (1 - \beta) L_t)\] <p>For the second term, using the inequality \(\log(1 - x) \leq -x\) for \(x &lt; 1\), we get:</p> \[\sum_{t=1}^{T} \log (1 - (1 - \beta) L_t) \leq \sum_{t=1}^{T} - (1 - \beta) L_T = - (1 - \beta) \mathcal{L}_T\] <p>Thus,</p> \[\log W_{T+1} \leq \log N - (1 - \beta) \mathcal{L}_T.\] <p>Similarly, for the lower bound:</p> \[\log W_{T+1} \geq \mathcal{L}_T^{\min} \log \beta\] <p>Combining these,</p> \[\mathcal{L}_T^{\min} \log \beta \leq \log N - (1 - \beta) \mathcal{L}_T.\] <p>Rearranging,</p> \[\mathcal{L}_T \leq \frac{\log N}{1 - \beta} - \frac{\log \beta}{1 - \beta} \mathcal{L}_T^{\min}\] \[\mathcal{L}_T \leq \log N - \frac{\log (1 - (1 - \beta))}{1 - \beta} \mathcal{L}_T^{\min}\] <p>Again, for this second term, using the inequality \(-\log(1 - x) \leq x+x^2\) for \(x \in [0, \frac{1}{2}]\), we get:</p> \[\mathcal{L}_T \leq \frac{\log N}{1 - \beta} + (2 - \beta) \mathcal{L}_T^{\min} \tag{1}\] <p>This is the main result, and it provides a clear bound on the cumulative loss \(\mathcal{L}_T\).</p> <hr> <p><strong>Step 5: Choosing Optimal \(\beta\)</strong></p> <p>We differentiate with respect to \(\beta\) and setting it to zero gives:</p> \[\frac{\log N}{(1 - \beta)^2} - T = 0\] <p>Solving for \(\beta\):</p> \[\beta = 1 - \sqrt{\frac{\log N}{T}} &lt; 1\] <p>If \(1 - \sqrt{\frac{\log N}{T}} \geq \frac{1}{2}\), then:</p> \[\beta_0 = 1 - \sqrt{\frac{\log N}{T}}\] <p>Otherwise, we use the boundary value \(\beta_0 = \frac{1}{2}\) is the optimal value.</p> <p>Substituting this choice in \((1)\), we get:</p> \[\mathcal{L}_T \leq \mathcal{L}_T^{\min} + 2\sqrt{T \log N} \tag{2}\] <p>Thus, the <strong>regret bound</strong> is:</p> \[R_T = \mathcal{L}_T - \mathcal{L}_T^{\min} \leq 2 \sqrt{T \log N}\] <p><strong>Key Essence:</strong></p> <ul> <li>The <strong>regret</strong> of the RWM algorithm is \(O(\sqrt{T \log N})\).</li> <li>The <strong>average regret per round \(R_T/T\)</strong> decreases as \(O(1/\sqrt{T})\).</li> </ul> <p>This result shows that RWM achieves <strong>sublinear regret</strong>, meaning that as the number of rounds \(T\) grows, the algorithm performs almost as well as the best expert.</p> <hr> <p>Do we really grasp what this formula is conveying? It highlights a remarkable bound in online learning. Alright, let’s dig into that further.</p> <p><strong>What does sublinear regret mean?</strong></p> <p>When we say that an algorithm has <strong>sublinear regret</strong>, we mean that the total regret <strong>grows slower than the number of rounds</strong>. As the number of rounds \(T\) increases, the gap between the algorithm’s performance and the best expert’s performance doesn’t increase linearly. Instead, it grows at a slower rate (e.g., \(\sqrt{T}\)).</p> <p><strong>The meaning of the formula:</strong></p> <ul> <li> <p><strong>Regret \(O(\sqrt{T \log N})\)</strong>: This tells you that after \(T\) rounds, the total regret will grow roughly as \(\sqrt{T}\), with an additional logarithmic factor based on \(N\) (the number of possible actions). The logarithmic term grows slowly and doesn’t significantly affect the overall growth for large \(T\).</p> </li> <li> <p><strong>Average regret per round \(O(1/\sqrt{T})\)</strong>: This shows that, on average, the regret per round decreases as the number of rounds increases. As \(T\) gets larger, the average regret (the loss per round) decreases.</p> </li> </ul> <p><strong>Sublinear regret in action:</strong></p> <ol> <li> <strong>At the start</strong>, when the algorithm has few rounds to learn, it might perform poorly (larger regret).</li> <li> <strong>Over time</strong>, as \(T\) grows, the algorithm’s performance improves. It makes fewer mistakes as it “learns” from past rounds, and the regret per round decreases.</li> <li> <strong>After many rounds</strong>, the algorithm performs almost as well as the best possible action, and the regret becomes quite small.</li> </ol> <p><strong>Key takeaway:</strong></p> <ul> <li> <strong>Sublinear regret</strong> means that the algorithm’s performance gets closer to the best possible action as the number of rounds increases, but it does so at a slower pace than linear growth. The algorithm doesn’t just keep getting worse with more rounds; instead, it converges toward optimal performance.</li> </ul> <p><strong>Note:</strong> The bound \((2)\) assumes that the algorithm additionally receives as a parameter the number of rounds \(T\). However, as we learned from the <a href="https://monishver11.github.io/blog/2025/doubling-trick/">Doubling trick</a> in the previous blog, this requirement can be relaxed at the cost of a small constant factor increase.</p> <hr> <h5 id="conclusion"><strong>Conclusion</strong></h5> <p>The <strong>Randomized Weighted Majority (RWM) Algorithm</strong> provides a powerful and efficient method for decision-making and prediction in online learning. The regret bound we’ve derived shows that, under the right conditions, the RWM algorithm can perform nearly as well as the best possible expert in hindsight, with a regret that grows at most as \(O(\sqrt{T \log N})\).</p> <p>This result is optimal, as demonstrated by further lower bound theorems, and provides a strong theoretical guarantee for the RWM algorithm’s performance in practice.</p> <h5 id="references"><strong>References</strong></h5> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Monishver Chandrasekaran. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1HD0LJE1KY"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1HD0LJE1KY");</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"Blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"A growing collection of my cool projects.",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-resume",title:"Resume",description:"",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"nav-thoughts",title:"Thoughts",description:"",section:"Navigation",handler:()=>{window.location.href="/thoughts/"}},{id:"post-big-data-storage",title:"Big Data Storage",description:"Notes on Big Data Storage - Concepts and Architecture",section:"Posts",handler:()=>{window.location.href="/blog/2025/big-data-2-storage/"}},{id:"post-introduction-to-realtime-and-big-data-analytics",title:"Introduction to Realtime and Big Data Analytics",description:"Notes on Big Data (the 5 V&#39;s &amp; data types) and the Four Categories of Data Analytics (Descriptive, Diagnostic, Predictive, and Prescriptive).",section:"Posts",handler:()=>{window.location.href="/blog/2025/big-data-1-intro/"}},{id:"post-gpu-essentials-a-concise-technical-guide",title:"GPU Essentials - A Concise Technical Guide",description:"A concise, technical guide to GPU architecture and CUDA, showing how massive parallelism is achieved through threads, blocks, SMs, and memory hierarchies.",section:"Posts",handler:()=>{window.location.href="/blog/2025/GPU-Intro/"}},{id:"post-wrapping-up-our-ml-foundations-journey",title:"Wrapping Up Our ML Foundations Journey",description:"A reflection on our exploration of machine learning fundamentals, from mathematical prerequisites to gradient boosting.",section:"Posts",handler:()=>{window.location.href="/blog/2025/wrapping-ml-basics/"}},{id:"post-gradient-boosting-in-practice",title:"Gradient Boosting in Practice",description:"Practical insights and regularization techniques to make gradient boosting robust, efficient, and generalize well in real-world applications.",section:"Posts",handler:()=>{window.location.href="/blog/2025/gb-in-practice/"}},{id:"post-binomialboost",title:"BinomialBoost",description:"See how the gradient boosting framework naturally extends to binary classification using the logistic loss.",section:"Posts",handler:()=>{window.location.href="/blog/2025/binomial-boost/"}},{id:"post-gradient-boosting-quot-anyboost-quot",title:"Gradient Boosting / &quot;Anyboost&quot;",description:"A clear and intuitive walkthrough of gradient boosting as functional gradient descent, with detailed explanations of residuals, step directions, and algorithmic structure.",section:"Posts",handler:()=>{window.location.href="/blog/2025/gradient-boosting/"}},{id:"post-forward-stagewise-additive-modeling",title:"Forward Stagewise Additive Modeling",description:"A clear walkthrough of FSAM and its role in boosting with exponential loss.",section:"Posts",handler:()=>{window.location.href="/blog/2025/FSAM/"}},{id:"post-introduction-to-gradient-boosting",title:"Introduction to Gradient Boosting",description:"A beginner-friendly introduction to gradient boosting, connecting empirical risk minimization, adaptive basis functions, and the challenges of non-differentiable models like decision trees.",section:"Posts",handler:()=>{window.location.href="/blog/2025/intro-gradient-boosting/"}},{id:"post-boosting-and-adaboost",title:"Boosting and AdaBoost",description:"This blog post provides an in-depth overview of boosting techniques, focusing on AdaBoost, explaining its key concepts, algorithm steps, and real-world applications in classification tasks.",section:"Posts",handler:()=>{window.location.href="/blog/2025/adaboost/"}},{id:"post-random-forests",title:"Random Forests",description:"Explore how Random Forests enhance Bagging by introducing randomness at each tree split, reducing correlation, and increasing diversity to build more accurate and stable prediction models.",section:"Posts",handler:()=>{window.location.href="/blog/2025/random-forest/"}},{id:"post-bagging-bootstrap-aggregation",title:"Bagging - Bootstrap Aggregation",description:"Bagging (Bootstrap Aggregating) combines multiple high-variance models trained on different bootstrap samples to create a more stable, accurate, and lower-variance ensemble predictor.",section:"Posts",handler:()=>{window.location.href="/blog/2025/bagging/"}},{id:"post-introduction-to-ensemble-methods",title:"Introduction to Ensemble Methods",description:"A beginner&#39;s guide to ensemble methods in machine learning, explaining how averaging and bootstrapping reduce variance and improve model performance.",section:"Posts",handler:()=>{window.location.href="/blog/2025/intro-to-ensemble-methods/"}},{id:"post-decision-trees-for-classification",title:"Decision Trees for Classification",description:"Explains what makes a good split, how impurity is quantified using Gini, Entropy, and misclassification error, and why trees are both powerful and interpretable.",section:"Posts",handler:()=>{window.location.href="/blog/2025/decision-trees-classification/"}},{id:"post-decision-trees-our-first-non-linear-classifier",title:"Decision Trees - Our First Non-Linear Classifier",description:"Learn how decision trees work for regression, including split criteria, overfitting control, and intuitive examples.",section:"Posts",handler:()=>{window.location.href="/blog/2025/decision-trees/"}},{id:"post-structured-perceptron-amp-structured-svm",title:"Structured Perceptron &amp; Structured SVM",description:"Understanding how Structured Perceptron and Structured SVM learn to predict structured outputs with interdependent components.",section:"Posts",handler:()=>{window.location.href="/blog/2025/structured-perceptron-svm/"}},{id:"post-structured-prediction-and-multiclass-svm",title:"Structured Prediction and Multiclass SVM",description:"An in-depth yet intuitive walkthrough of structured prediction, covering sequence labeling, feature engineering, and scoring methods for complex outputs.",section:"Posts",handler:()=>{window.location.href="/blog/2025/structured-prediction/"}},{id:"post-multiclass-classification-with-svm",title:"Multiclass Classification with SVM",description:"Learn how Support Vector Machines extend to multiclass classification with an intuitive breakdown of margin concepts, loss derivation, and the multiclass hinge loss formulation.",section:"Posts",handler:()=>{window.location.href="/blog/2025/multiclass-svm/"}},{id:"post-multiclass-logistic-regression-amp-multiclass-perceptron-algorithm",title:"Multiclass Logistic Regression &amp; Multiclass Perceptron Algorithm",description:"Learn the essentials of multiclass classification, focusing on logistic regression, perceptron algorithms, and efficient model building techniques.",section:"Posts",handler:()=>{window.location.href="/blog/2025/multiclass-loss/"}},{id:"post-multiclass-classification-overview",title:"Multiclass Classification - Overview",description:"Learn how One-vs-All and One-vs-One extend binary classification to multiclass problems, their key differences, and best use cases.",section:"Posts",handler:()=>{window.location.href="/blog/2025/multiclass/"}},{id:"post-gaussian-regression-a-bayesian-approach-to-linear-regression",title:"Gaussian Regression - A Bayesian Approach to Linear Regression",description:"This guide explores Gaussian regression, deriving its closed-form posterior, linking MAP estimation to ridge regression, and explaining predictive uncertainty for Bayesian inference.",section:"Posts",handler:()=>{window.location.href="/blog/2025/gaussian-regression/"}},{id:"post-my-understanding-of-quot-efficient-algorithms-for-online-decision-problems-quot-paper",title:"My Understanding of &quot;Efficient Algorithms for Online Decision Problems&quot; Paper",description:"A breakdown of Follow the Perturbed Leader (FPL) from Kalai &amp; Vempala\u2019s (2005) paper, &quot;Efficient Algorithms for Online Decision Problems.&quot; This blog explores how FPL improves online decision-making, minimizes regret, and extends to structured problems like shortest paths and adaptive Huffman coding.",section:"Posts",handler:()=>{window.location.href="/blog/2025/FPL-proof/"}},{id:"post-follow-the-leader-fl-and-follow-the-perturbed-leader-fpl-in-online-learning",title:"Follow the Leader (FL) and Follow the Perturbed Leader (FPL) in Online Learning...",description:"Discover how Follow the Leader (FL) and Follow the Perturbed Leader (FPL) work in online learning, their mathematical foundations, and how perturbations help achieve better stability and regret bounds.",section:"Posts",handler:()=>{window.location.href="/blog/2025/FPL/"}},{id:"post-bayesian-conditional-models",title:"Bayesian Conditional Models",description:"Learn how Bayesian conditional models leverage prior knowledge, posterior updates, and predictive distributions to make principled, uncertainty-aware predictions in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2025/bayes-conditional-models/"}},{id:"post-on-line-to-batch-conversion",title:"On-line to Batch Conversion",description:"Understanding how online learning algorithms can be used to derive hypotheses with small generalization error in a stochastic setting.",section:"Posts",handler:()=>{window.location.href="/blog/2025/online-to-batch/"}},{id:"post-randomized-weighted-majority-algorithm",title:"Randomized Weighted Majority Algorithm",description:"Learn how the Randomized Weighted Majority (RWM) Algorithm leverages probabilistic prediction to minimize regret and defend against adversarial strategies in online learning environments.",section:"Posts",handler:()=>{window.location.href="/blog/2025/RWM/"}},{id:"post-bayesian-decision-theory-concepts-and-recap",title:"Bayesian Decision Theory - Concepts and Recap",description:"A comprehensive guide to Bayesian decision theory, exploring its key components, point estimation, loss functions, and connections to classical probability modeling.",section:"Posts",handler:()=>{window.location.href="/blog/2025/bayes-decision-theory/"}},{id:"post-reinforcement-learning-an-introductory-guide",title:"Reinforcement Learning - An Introductory Guide",description:"Explore the foundations of intelligence, decision-making principles, and their application in reinforcement learning.",section:"Posts",handler:()=>{window.location.href="/blog/2025/rl-intro/"}},{id:"post-conjugate-priors-and-bayes-point-estimates",title:"Conjugate Priors and Bayes Point Estimates",description:"Learn how conjugate priors streamline Bayesian inference and discover  ways to summarize posterior distributions using Bayes point estimates.",section:"Posts",handler:()=>{window.location.href="/blog/2025/bayes-point-estimate/"}},{id:"post-doubling-trick-a-clever-strategy-to-handle-unknown-horizons",title:"Doubling Trick - A Clever Strategy to Handle Unknown Horizons",description:"Discover how the Doubling Trick enables online algorithms to adapt to unknown horizons, maintaining competitive regret bounds.",section:"Posts",handler:()=>{window.location.href="/blog/2025/doubling-trick/"}},{id:"post-exponential-weighted-average-algorithm",title:"Exponential Weighted Average Algorithm",description:"Delve into the Exponential Weighted Average Algorithm, its regret bounds, and the mathematical proof ensuring efficient loss minimization.",section:"Posts",handler:()=>{window.location.href="/blog/2025/EWA/"}},{id:"post-bayesian-machine-learning-mathematical-foundations",title:"Bayesian Machine Learning - Mathematical Foundations",description:"A beginner-friendly guide to Bayesian statistics, explaining priors, likelihoods, posteriors, and real-world examples like coin-flipping to build a clear and intuitive understanding.",section:"Posts",handler:()=>{window.location.href="/blog/2025/Bayesian-ML/"}},{id:"post-understanding-the-weighted-majority-algorithm-in-online-learning",title:"Understanding the Weighted Majority Algorithm in Online Learning",description:"Explore how the Weighted Majority Algorithm achieves robust bounds for adversarial settings by adapting expert weights with every mistake.",section:"Posts",handler:()=>{window.location.href="/blog/2025/WMA/"}},{id:"post-online-learning-in-ml-a-beginner-s-guide-to-adaptive-learning",title:"Online Learning in ML - A Beginner\u2019s Guide to Adaptive Learning",description:"Learn how online learning transforms machine learning by handling dynamic, real-time data and adversarial scenarios. Explore its advantages, real-world applications, and key concepts like regret minimization and the Halving Algorithm in this beginner-friendly guide to adaptive AI.",section:"Posts",handler:()=>{window.location.href="/blog/2025/Online-Learning/"}},{id:"post-multivariate-gaussian-distribution-and-naive-bayes",title:"Multivariate Gaussian Distribution and Naive Bayes",description:"Dive into the multivariate Gaussian distribution, its role in probabilistic modeling, and how it powers Naive Bayes classifiers with practical insights and mathematical intuition.",section:"Posts",handler:()=>{window.location.href="/blog/2025/Multivariate-GNB/"}},{id:"post-gaussian-naive-bayes-a-natural-extension",title:"Gaussian Naive Bayes - A Natural Extension",description:"Explore how Gaussian Naive Bayes adapts to continuous inputs, including parameter estimation, decision boundaries, and its relation to logistic regression.",section:"Posts",handler:()=>{window.location.href="/blog/2025/NB-continuous-features/"}},{id:"post-an-introduction-to-generative-models-naive-bayes-for-binary-features",title:"An Introduction to Generative Models - Naive Bayes for Binary Features",description:"Learn the fundamentals of Naive Bayes, from its conditional independence assumption to the maximum likelihood estimation (MLE) of parameters, using a binary feature example.",section:"Posts",handler:()=>{window.location.href="/blog/2025/generative-models/"}},{id:"post-generalized-linear-models-explained-leveraging-mle-for-regression-and-classification",title:"Generalized Linear Models Explained - Leveraging MLE for Regression and Classification",description:"Explore how Maximum Likelihood Estimation (MLE) forms the backbone of generalized linear models, enabling robust solutions for regression, classification, and beyond.",section:"Posts",handler:()=>{window.location.href="/blog/2025/MLE/"}},{id:"post-unveiling-probabilistic-modeling",title:"Unveiling Probabilistic Modeling",description:"Explore the fundamentals of probabilistic modeling and how it enhances our understanding of linear regression, from parameter estimation to error distribution.",section:"Posts",handler:()=>{window.location.href="/blog/2025/probabilistic-modeling/"}},{id:"post-svm-solution-in-the-span-of-the-data",title:"SVM Solution in the Span of the Data",description:"This blog explores how the span property simplifies optimization in SVM and ridge regression, introduces the Representer Theorem, and highlights the computational benefits of kernelization.",section:"Posts",handler:()=>{window.location.href="/blog/2025/svm-solution-span-of-data/"}},{id:"post-understanding-the-kernel-trick",title:"Understanding the Kernel Trick",description:"A step-by-step exploration of kernel methods, unraveling their role in enabling powerful nonlinear modeling through the elegance of the kernel trick.",section:"Posts",handler:()=>{window.location.href="/blog/2025/kernel-trick/"}},{id:"post-unleashing-the-power-of-linear-models-tackling-nonlinearity-with-feature-maps",title:"Unleashing the Power of Linear Models - Tackling Nonlinearity with Feature Maps",description:"Explore how feature maps transform inputs, handle nonlinearities, and expand the expressiveness of linear models with practical examples and intuitive solutions.",section:"Posts",handler:()=>{window.location.href="/blog/2025/feature-maps/"}},{id:"post-demystifying-svms-understanding-complementary-slackness-and-support-vectors",title:"Demystifying SVMs - Understanding Complementary Slackness and Support Vectors",description:"A deep dive into the complementary slackness conditions in SVMs, exploring their connection to margins, support vectors, and kernelized optimization for powerful classification.",section:"Posts",handler:()=>{window.location.href="/blog/2025/svm-dual-problem/"}},{id:"post-the-dual-problem-of-svm",title:"The Dual Problem of SVM",description:"An in-depth exploration of the dual problem in SVMs, covering its mathematical foundation, Lagrangian formulation, duality principles, and complementary slackness for intuitive understanding.",section:"Posts",handler:()=>{window.location.href="/blog/2025/dual-problem/"}},{id:"post-subgradient-and-subgradient-descent",title:"Subgradient and Subgradient Descent",description:"An deep dive into subgradients, subgradient descent, and their application in optimizing non-differentiable functions like SVMs.",section:"Posts",handler:()=>{window.location.href="/blog/2025/subgradient/"}},{id:"post-support-vector-machines-svm-from-hinge-loss-to-optimization",title:"Support Vector Machines(SVM) - From Hinge Loss to Optimization",description:"Demystifying Support Vector Machines (SVM) - A step-by-step exploration of hinge loss, optimization, and gradient mechanics.",section:"Posts",handler:()=>{window.location.href="/blog/2025/svm/"}},{id:"post-understanding-the-maximum-margin-classifier",title:"Understanding the Maximum Margin Classifier",description:"An engaging walkthrough of maximum margin classifiers, exploring their foundations, geometric insights, and the transition to support vector machines.",section:"Posts",handler:()=>{window.location.href="/blog/2025/max-margin-classifier/"}},{id:"post-l1-and-l2-regularization-nuanced-details",title:"L1 and L2 Regularization - Nuanced Details",description:"A detailed explanation of L1 and L2 regularization, focusing on their theoretical insights, geometric interpretations, and practical implications for machine learning models.",section:"Posts",handler:()=>{window.location.href="/blog/2025/l1-l2-reg-indepth/"}},{id:"post-regularization-balancing-model-complexity-and-overfitting",title:"Regularization - Balancing Model Complexity and Overfitting",description:"Discover how regularization controls model complexity, reduces overfitting, and enhances generalization in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2025/regularization/"}},{id:"post-loss-functions-regression-and-classification",title:"Loss Functions - Regression and Classification",description:"Exploring regression and classification loss functions, with a deep dive into logistic regression and its role in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2025/loss-functions/"}},{id:"post-optimizing-stochastic-gradient-descent-key-recommendations-for-effective-training",title:"Optimizing Stochastic Gradient Descent - Key Recommendations for Effective Training",description:"A comprehensive collection of expert recommendations to enhance the performance and reliability of Stochastic Gradient Descent, ensuring smoother and faster convergence during training.",section:"Posts",handler:()=>{window.location.href="/blog/2025/sgd-tips/"}},{id:"post-gradient-descent-and-second-order-optimization-a-thorough-comparison",title:"Gradient Descent and Second-Order Optimization - A Thorough Comparison",description:"An in-depth exploration of Gradient Descent (GD) and Second-Order Gradient Descent (2GD), focusing on convergence behavior, mathematical derivations, and performance differences.",section:"Posts",handler:()=>{window.location.href="/blog/2024/gd-tips/"}},{id:"post-gradient-descent-convergence-prerequisites-and-detailed-derivation",title:"Gradient Descent Convergence - Prerequisites and Detailed Derivation",description:"Understanding the convergence of gradient descent with a fixed step size and proving its rate of convergence for convex, differentiable functions.",section:"Posts",handler:()=>{window.location.href="/blog/2024/gd-convergence/"}},{id:"post-understanding-stochastic-gradient-descent-sgd",title:"Understanding Stochastic Gradient Descent (SGD)",description:"A detailed guide to gradient descent variants, highlighting the mechanics, trade-offs, and practical insights of Stochastic Gradient Descent (SGD).",section:"Posts",handler:()=>{window.location.href="/blog/2024/SGD/"}},{id:"post-gradient-descent-a-detailed-walkthrough",title:"Gradient Descent - A Detailed Walkthrough",description:"An in-depth exploration of gradient descent, including its convergence and step size considerations.",section:"Posts",handler:()=>{window.location.href="/blog/2024/gradient-descent/"}},{id:"post-empirical-risk-minimization-erm",title:"Empirical Risk Minimization (ERM)",description:"Exploring Empirical Risk Minimization - Balancing approximation, estimation, and optimization errors to build effective supervised learning models.",section:"Posts",handler:()=>{window.location.href="/blog/2024/ERM/"}},{id:"post-understanding-the-supervised-learning-setup",title:"Understanding the Supervised Learning Setup",description:"An in-depth exploration of the supervised learning setup, covering key concepts like prediction functions, loss functions, risk evaluation, and the Bayes optimal predictor.",section:"Posts",handler:()=>{window.location.href="/blog/2024/supervised-learning/"}},{id:"post-timeline-of-machine-learning-history",title:"Timeline of Machine Learning History",description:"A concise timeline of machine learning&#39;s history, showcasing key milestones and breakthroughs that shaped the field.",section:"Posts",handler:()=>{window.location.href="/blog/2024/ml-history/"}},{id:"post-advanced-probability-concepts-for-machine-learning",title:"Advanced Probability Concepts for Machine Learning",description:"This blog explores key probability theory concepts, from distributions and Bayes&#39; Theorem to covariance and the Central Limit Theorem, emphasizing their critical application in machine learning and statistical modeling.",section:"Posts",handler:()=>{window.location.href="/blog/2024/probability-2/"}},{id:"post-understanding-the-basics-of-probability-theory-for-machine-learning",title:"Understanding the Basics of Probability Theory for Machine Learning",description:"This blog explores essential probability concepts and their significance in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2024/probability-1/"}},{id:"post-linear-algebra-prerequisites-for-machine-learning",title:"Linear Algebra - Prerequisites for Machine Learning",description:"This blog post covers the key linear algebra concepts and their applications in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2024/linear-algebra/"}},{id:"post-multivariate-calculus-prerequisites-for-machine-learning",title:"Multivariate Calculus - Prerequisites for Machine Learning",description:"This blog post explores key multivariate calculus concepts essential for understanding optimization in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2024/multivariate-calculus/"}},{id:"post-introduction-to-machine-learning-ml",title:"Introduction to Machine Learning(ML)",description:"An easy guide to machine learning, its applications, and how it connects to AI and human learning.",section:"Posts",handler:()=>{window.location.href="/blog/2024/intro-to-ml/"}},{id:"post-preface-amp-introduction",title:"Preface &amp; Introduction",description:"First blog post\u2014setting the stage for the journey ahead.",section:"Posts",handler:()=>{window.location.href="/blog/2024/preface-ml/"}},{id:"news-spring-2025-semester-update",title:"Spring 2025 Semester Update",description:"",section:"News",handler:()=>{window.location.href="/news/announcement_1/"}},{id:"news-sharing-personal-reflections-thoughts-tab-thoughts",title:"Sharing personal reflections - [Thoughts Tab](/thoughts/)",description:"",section:"News"},{id:"news-wrapping-up-our-ml-foundations-journey-blog-2025-wrapping-ml-basics",title:"[Wrapping Up Our ML Foundations Journey](/blog/2025/wrapping-ml-basics/)",description:"",section:"News"},{id:"projects-mta-transit-time-prediction",title:"MTA Transit Time Prediction",description:"Leveraging real-time data and machine learning to predict bus arrival times in New York City with route-based and grid-based approaches.",section:"Projects",handler:()=>{window.location.href="/projects/1_project/"}},{id:"projects-gaze-guided-reinforcement-learning-for-visual-search",title:"Gaze-Guided Reinforcement Learning for Visual Search",description:"Discover how gaze prediction from human eye-tracking enhances AI agents in object search tasks. By integrating visual attention into reinforcement learning through three novel methods, our approach enables faster, more effective navigation in simulated environments.",section:"Projects",handler:()=>{window.location.href="/projects/2_project/"}},{id:"projects-understanding-swap-regret-2-0",title:"Understanding Swap Regret 2.0",description:"This blog post unpacks the &quot;Swap Regret 2.0&quot; paper through slide-by-slide insights, showing how the TreeSwap algorithm closes the gap between external and swap regret, advancing equilibrium computation in game theory and reinforcement learning.",section:"Projects",handler:()=>{window.location.href="/projects/3_project/"}},{id:"social-email",title:"email",section:"Socials",handler:()=>{window.open("mailto:%6D%6F%6E%69%73%68%76%65%72%63%68%61%6E%64%72%61%73%65%6B%61%72%61%6E@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"social-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/Monishver11","_blank")}},{id:"social-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/monishver","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>