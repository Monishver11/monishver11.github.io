<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="9O0EoPaLhgFjSIvAkDDoQK0gr49C2Wuxtgl3c0bXObM"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Demystifying SVMs - Understanding Complementary Slackness and Support Vectors | Monishver Chandrasekaran </title> <meta name="author" content="Monishver Chandrasekaran"> <meta name="description" content="A deep dive into the complementary slackness conditions in SVMs, exploring their connection to margins, support vectors, and kernelized optimization for powerful classification."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%94%A5&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://monishver11.github.io/blog/2025/svm-dual-problem/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class=" "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm sticky-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Monishver</span> Chandrasekaran </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Demystifying SVMs - Understanding Complementary Slackness and Support Vectors</h1> <p class="post-meta"> Created in January 10, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/ml"> <i class="fa-solid fa-hashtag fa-sm"></i> ML</a>   <a href="/blog/tag/math"> <i class="fa-solid fa-hashtag fa-sm"></i> Math</a>   ·   <a href="/blog/category/ml-nyu"> <i class="fa-solid fa-tag fa-sm"></i> ML-NYU</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>At the heart of SVMs lies a fascinating optimization framework that balances maximizing the margin between classes and minimizing classification errors. This post dives into the dual formulation of the SVM optimization problem, exploring its mathematical underpinnings, derivation, and insights.</p> <hr> <h4 id="the-svm-primal-problem"><strong>The SVM Primal Problem</strong></h4> <p>To understand the dual problem, we first start with the <strong>primal optimization problem</strong> of SVMs. It aims to find the optimal hyperplane that separates two classes while allowing for some misclassification through slack variables. The primal problem is expressed as:</p> \[\min_{w, b, \xi} \frac{1}{2} \|w\|^2 + \frac{c}{n} \sum_{i=1}^n \xi_i\] <p>subject to the constraints:</p> \[-\xi_i \leq 0 \quad \text{for } i = 1, \dots, n\] \[1 - y_i (w^T x_i + b) - \xi_i \leq 0 \quad \text{for } i = 1, \dots, n\] <p>Here:</p> <ul> <li>\(w\) is the weight vector defining the hyperplane,</li> <li>\(b\) is the bias term,</li> <li>\(\xi_i\) are slack variables that allow some points to violate the margin, and</li> <li>\(C\) is the regularization parameter controlling the trade-off between maximizing the margin and minimizing errors.</li> </ul> <h4 id="lagrangian-formulation"><strong>Lagrangian Formulation</strong></h4> <p>To solve this constrained optimization problem, we use the method of <strong>Lagrange multipliers</strong>. Introducing \(\alpha_i\) and \(\lambda_i\) as multipliers for the inequality constraints, the <strong>Lagrangian</strong> becomes:</p> \[L(w, b, \xi, \alpha, \lambda) = \frac{1}{2} \|w\|^2 + \frac{c}{n} \sum_{i=1}^n \xi_i + \sum_{i=1}^n \alpha_i \left( 1 - y_i (w^T x_i + b) - \xi_i \right) + \sum_{i=1}^n \lambda_i (-\xi_i)\] <p>Here, the terms involving \(\alpha_i\) and \(\lambda_i\) enforce the constraints, while the first term captures the objective of maximizing the margin.</p> <table> <thead> <tr> <th>Lagrange Multiplier</th> <th>Constraint</th> </tr> </thead> <tbody> <tr> <td>\(\lambda_i\)</td> <td>\(-\xi_i \leq 0\)</td> </tr> <tr> <td>\(\alpha_i\)</td> <td>\((1 - y_i[w^T x_i + b]) - \xi_i \leq 0\)</td> </tr> </tbody> </table> <hr> <h4 id="strong-duality-and-slaters-condition"><strong>Strong Duality and Slater’s Condition</strong></h4> <p>The next step is to leverage <strong>strong duality</strong>, which states that for certain optimization problems, the dual problem provides the same optimal value as the primal. For SVMs, strong duality holds due to <strong>Slater’s constraint qualification</strong>, which requires the problem to:</p> <ul> <li>Have a convex objective function,</li> <li>Include affine constraints, and</li> <li>Possess feasible points.</li> </ul> <p>In the context of <strong>Slater’s constraint qualification</strong> and <strong>strong duality</strong> for SVMs, <strong>feasible points</strong> refer to points in the feasible region that satisfy all the constraints of the primal optimization problem. Specifically, for SVMs, these points are:</p> <ol> <li> <p><strong>Convex Objective Function</strong>: The objective of the SVM (maximizing the margin, which is a quadratic optimization problem) is convex, meaning it has a global minimum.</p> </li> <li> <p><strong>Affine Constraints</strong>: These constraints are linear equations (or inequalities) that define the feasible region, such as ensuring that all data points are correctly classified. In mathematical form, for each data point \(y_i (\mathbf{w}^T \mathbf{x}_i + b) \geq 1\).</p> </li> <li> <p><strong>Existence of Feasible Points</strong>: There must be at least one point in the domain that satisfies all of these constraints. In SVMs, this is satisfied when the data is linearly separable, meaning there exists a hyperplane that can perfectly separate the positive and negative classes. Slater’s condition requires that there be strictly feasible points, where the constraints are strictly satisfied (i.e., not just touching the boundary of the feasible region).</p> </li> </ol> <p>For SVMs, the feasible points are those that satisfy: \(y_i (\mathbf{w}^T \mathbf{x}_i + b) \geq 1 \quad \text{for all data points}\)</p> <p>These points are strictly inside the feasible region, meaning there is a margin between the hyperplane and the data points, ensuring a gap.</p> <p>In practical terms, <strong>Slater’s condition</strong> implies that there exists a hyperplane that not only separates the two classes but also satisfies the strict inequalities for the margin (i.e., it does not lie on the boundary). This strict feasibility is critical for the <strong>strong duality</strong> theorem to hold.</p> <h4 id="deriving-the-svm-dual-function"><strong>Deriving the SVM Dual Function</strong></h4> <p>The dual function is obtained by minimizing the Lagrangian over the primal variables \(w\), \(b\), and \(\xi\):</p> \[g(\alpha, \lambda) = \inf_{w, b, \xi} L(w, b, \xi, \alpha, \lambda)\] <p>This can be simplified to (after shuffling and grouping):</p> \[g(\alpha, \lambda) = \inf_{w, b, \xi} \left[ \frac{1}{2} w^T w + \sum_{i=1}^n \xi_i \left( \frac{c}{n} - \alpha_i - \lambda_i \right) + \sum_{i=1}^n \alpha_i \left( 1 - y_i \left[ w^T x_i + b \right] \right) \right]\] <p>This minimization leads to the following <strong>first-order optimality conditions</strong>:</p> <ol> <li> <p><strong>Gradient with respect to \(w\):</strong> Differentiating \(L\) with respect to \(w\), we get:</p> \[\frac{\partial L}{\partial w} = w - \sum_{i=1}^n \alpha_i y_i x_i = 0\] <p>Solving for \(w\), we find:</p> \[w = \sum_{i=1}^n \alpha_i y_i x_i\] </li> <li> <p><strong>Gradient with respect to \(b\):</strong> Differentiating \(L\) with respect to \(b\), we obtain:</p> \[\frac{\partial L}{\partial b} = -\sum_{i=1}^n \alpha_i y_i = 0\] <p>This implies the constraint:</p> \[\sum_{i=1}^n \alpha_i y_i = 0\] </li> <li> <p><strong>Gradient with respect to \(\xi_i\):</strong> Differentiating \(L\) with respect to \(\xi_i\), we have:</p> \[\frac{\partial L}{\partial \xi_i} = \frac{c}{n} - \alpha_i - \lambda_i = 0\] <p>This leads to the relationship:</p> \[\alpha_i + \lambda_i = \frac{c}{n}\] </li> </ol> <h4 id="the-svm-dual-problem"><strong>The SVM Dual Problem</strong></h4> <p>Substituting these conditions back into \(L\)(Lagrangian), the second term disappears.</p> <p>First and third terms become:</p> \[\frac{1}{2}w^T w = \frac{1}{2}\sum_{i,j} \alpha_i \alpha_j y_i y_j x_j^T x_i\] \[\sum_{i=1}^n \alpha_i \left( 1 - y_i \left[ w^T x_i + b \right] \right) = \sum_i \alpha_i - \sum_{i,j} \alpha_i \alpha_j y_i y_j x_j^T x_i - b \sum_{i=1}^n \alpha_i y_i\] <p>Putting it together, the dual function is:</p> \[g(\alpha, \lambda) = \begin{cases} \sum_{i=1}^{n} \alpha_i - \frac{1}{2}\sum_{i,j=1}^{n} \alpha_i \alpha_j y_i y_j x_j^T x_i &amp; \text{if } \sum_{i=1}^{n} \alpha_i y_i = 0 \text{ and } \alpha_i + \lambda_i = \frac{c}{n}, \text{ all } i \\ -\infty &amp; \text{otherwise} \end{cases}\] <p><strong>Quick tip</strong>: Go ahead and write the derivation yourself to see what cancels out. It’s much easier to follow the flow this way, and you’ll better understand how the second term in the equation above is derived.</p> <p><strong>The dual problem is</strong></p> \[\sup_{\alpha, \lambda \geq 0} g(\alpha, \lambda)\] \[\text{s.t. } \begin{cases} \sum_{i=1}^{n} \alpha_i y_i = 0 \\ \alpha_i + \lambda_i = \frac{c}{n}, \text{ } \alpha_i, \lambda_i \geq 0, \text{ } i = 1, ..., n \end{cases}\] <p>Don’t stress over this complex equation; we’ll break down its meaning and significance as we continue. Keep reading!</p> <h5 id="insights-from-the-dual-problem"><strong>Insights from the Dual Problem</strong></h5> <p>The dual problem offers several key insights into the optimization process of SVMs:</p> <ol> <li> <p><strong>Duality and Optimality:</strong><br> Strong duality ensures that the primal and dual problems yield the same optimal value, provided conditions like Slater’s are met.</p> </li> <li> <p><strong>Dual Variables:</strong><br> The variables \(\alpha_i\) and \(\lambda_i\) are Lagrange multipliers, indicating how sensitive the objective function is to the constraints. Large \(\alpha_i\) values correspond to constraints that are most violated.</p> </li> <li> <p><strong>Constraint Interpretation:</strong><br> The constraint \(\sum_{i=1}^{n} \alpha_i y_i = 0\) ensures the hyperplane passes through the origin, while \(\alpha_i + \lambda_i = \frac{c}{n}\) connects the dual variables with the regularization parameter \(c\).</p> </li> <li> <p><strong>Support Vectors:</strong><br> Non-zero \(\alpha_i\) values indicate support vectors, which are the data points closest to the decision boundary and crucial for defining the margin.</p> </li> <li> <p><strong>Weight Vector Representation:</strong><br> The weight vector \(w\) lies in the space spanned by the support vectors: \(w = \sum_{i=1}^n \alpha_i y_i x_i\)</p> </li> </ol> <p>In essence, the dual problem simplifies the primal by focusing on constraints and provides insights into how data points affect the model’s decision boundary.</p> <h4 id="kkt-conditions"><strong>KKT Conditions</strong></h4> <p>For convex problems, if Slater’s condition is satisfied, the <strong>Karush-Kuhn-Tucker (KKT) conditions</strong> provide necessary and sufficient conditions for the optimal solution. For the <strong>SVM dual problem</strong>, these conditions can be expressed as:</p> <ul> <li> <p><strong>Primal Feasibility:</strong> \(f_i(x) \leq 0 \quad \forall i\)<br> This condition ensures that the constraints of the primal problem are satisfied. In the context of SVM, this means that all data points are correctly classified by the hyperplane, i.e., for each data point \(i\), the constraint \(y_i (\mathbf{w}^T \mathbf{x}_i + b) \geq 1\) is satisfied.</p> </li> <li> <p><strong>Dual Feasibility:</strong> \(\lambda_i \geq 0\)<br> This condition ensures that the dual variables (Lagrange multipliers) are non-negative. For SVMs, it means the Lagrange multipliers \(\alpha_i\) associated with the classification constraints must be non-negative, i.e., \(\alpha_i \geq 0\).</p> </li> <li> <p><strong>Complementary Slackness:</strong> \(\lambda_i f_i(x) = 0\)<br> This condition means that either the constraint is <strong>active</strong> (i.e., the constraint is satisfied with equality) or the dual variable is zero. For SVMs, it implies that if a data point is a support vector (i.e., it lies on the margin), then the corresponding \(\alpha_i\) is positive. Otherwise, for non-support vectors, \(\alpha_i = 0\).</p> </li> <li> <p><strong>First-Order Condition:</strong> \(\frac{\partial}{\partial x} L(x, \lambda) = 0\)<br> The first-order condition ensures that the Lagrangian \(L(x, \lambda)\) is minimized with respect to the optimization variables. In SVMs, this condition leads to the optimal weights \(\mathbf{w}\) and bias \(b\) that define the separating hyperplane.</p> </li> </ul> <p><strong>To summarize</strong>:</p> <ul> <li> <strong>Slater’s Condition</strong> ensures strong duality.</li> <li> <strong>KKT Conditions</strong> ensure the existence of the optimal solution and give the specific conditions under which the solution occurs.</li> </ul> <h4 id="the-svm-dual-solution"><strong>The SVM Dual Solution</strong></h4> <p>We can express the <strong>SVM dual problem</strong> as follows:</p> \[\sup_{\alpha} \sum_{i=1}^{n} \alpha_{i} - \frac{1}{2} \sum_{i,j=1}^{n} \alpha_{i} \alpha_{j} y_{i} y_{j} x_{j}^{T} x_{i}\] <p>subject to:</p> \[\sum_{i=1}^{n} \alpha_{i} y_{i} = 0\] \[\alpha_{i} \in [0, \frac{c}{n}], \quad i = 1, ..., n\] <p>In this formulation, \(\alpha_i\) are the Lagrange multipliers, which must satisfy the constraints. The dual problem maximizes the objective function involving these multipliers, while ensuring that the constraints are met.</p> <p>Once we have the optimal solution \(\alpha^*\) to the dual problem, the primal solution \(w^*\) can be derived as:</p> \[w^{*} = \sum_{i=1}^{n} \alpha_{i}^{*} y_{i} x_{i}\] <p>This shows that the optimal weight vector \(w^*\) is a linear combination of the input vectors \(x_i\), weighted by the corresponding \(\alpha_i^*\) and \(y_i\).</p> <p>It’s important to note that the solution is in the <strong>space spanned by the inputs</strong>. This means the decision boundary is influenced by the data points that lie closest to the hyperplane, i.e., the <strong>support vectors</strong>.</p> <p>The constraints \(\alpha_{i} \in [0, c/n]\) indicate that \(c\) controls the maximum weight assigned to each example. In other words, \(c\) acts as a regularization parameter, controlling the trade-off between achieving a large margin and minimizing classification errors. A larger \(c\) leads to less regularization, allowing the model to fit more closely to the training data, while a smaller \(c\) introduces more regularization, promoting a simpler model that may generalize better.</p> <p>Think of \(c\) as a <strong>“penalty meter”</strong> that controls how much you care about fitting the training data:</p> <ul> <li>A <strong>high \(c\)</strong> means you are <strong>less tolerant of mistakes</strong>. The model will try to fit the data perfectly, even if it leads to overfitting (less regularization).</li> <li>A <strong>low \(c\)</strong> means you’re more focused on <strong>simplicity and generalization</strong>. The model will allow some mistakes in the training data to avoid overfitting and create a smoother decision boundary (more regularization).</li> </ul> <p>Next, we will explore how the <strong>Complementary Slackness</strong> condition in the SVM dual formulation extends to <strong>kernel trick</strong>, enabling SVMs to handle non-linear decision boundaries effectively.</p> <hr> <h4 id="understanding-complementary-slackness-in-svms"><strong>Understanding Complementary Slackness in SVMs</strong></h4> <p>In this section, we will focus on <strong>complementary slackness</strong>, a key property of optimization problems, and its implications for SVMs. Then we will explore how it connects with the margin, slack variables, and the role of support vectors.</p> <h5 id="revisiting-constraints-and-lagrange-multipliers"><strong>Revisiting Constraints and Lagrange Multipliers</strong></h5> <p>To understand complementary slackness, let’s start by recalling the constraints and Lagrange multipliers in the SVM problem:</p> <ol> <li> <p>The constraint on the slack variables:</p> \[-\xi_i \leq 0,\] <p>with Lagrange multiplier \(\lambda_i\).</p> </li> <li> <p>The margin constraint:</p> \[1 - y_i f(x_i) - \xi_i \leq 0,\] <p>with Lagrange multiplier \(\alpha_i\).</p> </li> </ol> <p>From the <strong>first-order condition</strong> with respect to \(\xi_i\), we derived the relationship:</p> \[\lambda_i^* = \frac{c}{n} - \alpha_i^*,\] <p>where \(c\) is the regularization parameter.</p> <p>By <strong>strong duality</strong>, the complementary slackness conditions must hold, which state:</p> \[\alpha_i^* \left( 1 - y_i f^*(x_i) - \xi_i^* \right) = 0\] <p>and,</p> \[\lambda_i^* \xi_i^* = \left( \frac{c}{n} - \alpha_i^* \right) \xi_i^* = 0\] <p>These conditions essentially enforce that either the constraints are satisfied exactly or their corresponding Lagrange multipliers vanish.</p> <h5 id="what-does-complementary-slackness-tell-us"><strong>What Does Complementary Slackness Tell Us?</strong></h5> <p>Complementary slackness provides crucial insights into the relationship between the dual variables \(\alpha_i^*\), the slack variables \(\xi_i^*\), and the margin \(1 - y_i f^*(x_i)\). Let’s break this down:</p> <ul> <li> <strong>When \(y_i f^*(x_i) &gt; 1\):</strong> <ul> <li>The margin loss is zero (\(\xi_i^* = 0\)), meaning the data point is correctly classified and lies outside the margin.</li> <li>As a result, \(\alpha_i^* = 0\). Since the dual variable \(\alpha_i^*\) only applies to active constraints, a zero value indicates that this example has no effect on the decision boundary. These are non-support vectors that do not influence the margin or hyperplane.</li> </ul> </li> <li> <strong>When \(y_i f^*(x_i) &lt; 1\):</strong> <ul> <li>The margin loss is positive (\(\xi_i^* &gt; 0\)), meaning the data point either lies inside the margin or is misclassified.</li> <li>In this case, \(\alpha_i^* = \frac{c}{n}\), assigning the maximum weight to these examples. These points are critical as they represent either boundary violations or significant misclassifications, making them influential in determining the hyperplane.</li> </ul> </li> <li> <strong>When \(\alpha_i^* = 0\):</strong> <ul> <li>This implies \(\xi_i^* = 0\), meaning the margin loss is zero and the data point satisfies \(y_i f^*(x_i) \geq 1\).</li> <li>Such examples are correctly classified and lie well outside the margin, contributing nothing to the optimization. They remain irrelevant to the final decision boundary.</li> </ul> </li> <li> <strong>When \(\alpha_i^* \in (0, \frac{c}{n})\):</strong> <ul> <li>This implies \(\xi_i^* = 0\), so the example lies exactly on the margin, where \(1 - y_i f^*(x_i) = 0\).</li> <li>These are the <strong>support vectors</strong>, the critical points that define the hyperplane. Their non-zero \(\alpha_i^*\) values indicate their contribution to maximizing the margin while satisfying the constraints.</li> </ul> </li> </ul> <p><strong>Why It Matters?</strong> Complementary slackness essentially acts as a filter, identifying which examples influence the decision boundary (support vectors) and which do not. It helps focus only on the most relevant points, reducing computational complexity and enhancing the interpretability of the model.</p> <p>We can summarize these relationships(between margin and example weights) as follows:</p> <ol> <li> <strong>If \(\alpha_i^* = 0\):</strong> The example satisfies \(y_i f^*(x_i) \geq 1\), indicating no margin loss.</li> <li> <strong>If \(\alpha_i^* \in (0, \frac{c}{n})\):</strong> The example lies exactly on the margin, with \(y_i f^*(x_i) = 1\).</li> <li> <strong>If \(\alpha_i^* = \frac{c}{n}\):</strong> The example incurs a margin loss, with \(y_i f^*(x_i) \leq 1\).</li> </ol> <p>and the other way is:</p> \[y_if^*(x_i) &lt; 1 \Rightarrow α_i^* = \frac{c}{n}\] \[y_if^*(x_i) = 1 \Rightarrow α_i^* \in [0, \frac{c}{n}]\] \[y_if^*(x_i) &gt; 1 \Rightarrow α_i^* = 0\] <p>These relationships are foundational to understanding how SVMs allocate weights to examples and define the decision boundary.</p> <h5 id="analogy-tug-of-war-with-a-rope"><strong>Analogy: Tug of War with a Rope</strong></h5> <p>Imagine a tug-of-war game where each data point is trying to pull a rope (the decision boundary) towards itself. The strength of the pull (weight \(\alpha_i^*\)) depends on how far the point is from the ideal margin position:</p> <ol> <li> <strong>If the point is far outside the margin (\(y_i f^*(x_i) &gt; 1\)):</strong> <ul> <li> <strong>No pull (\(\alpha_i^* = 0\)):</strong><br> The point is satisfied with its position and doesn’t exert any force on the rope. It’s correctly classified and irrelevant to defining the decision boundary.</li> </ul> </li> <li> <strong>If the point is exactly on the margin (\(y_i f^*(x_i) = 1\)):</strong> <ul> <li> <strong>Light pull (\(\alpha_i^* \in [0, \frac{c}{n}]\)):</strong><br> The point contributes just enough force to keep the rope in its place. These are the <strong>support vectors</strong>, the critical points holding the boundary in position.</li> </ul> </li> <li> <strong>If the point is inside the margin or misclassified (\(y_i f^*(x_i) &lt; 1\)):</strong> <ul> <li> <strong>Maximum pull (\(\alpha_i^* = \frac{c}{n}\)):</strong><br> The point exerts its full force, pulling the boundary to correct the violation. These points dominate the optimization problem because they need the most adjustment.</li> </ul> </li> </ol> <p>Looking at it from the perspective of \(y_i f^*(x_i)\):</p> <ul> <li> <strong>\(y_i f^*(x_i) &gt; 1\):</strong> No pull (\(\alpha_i^* = 0\)) – the point is far and satisfied.</li> <li> <strong>\(y_i f^*(x_i) = 1\):</strong> Light pull (\(\alpha_i^* \in [0, \frac{c}{n}]\)) – the point is holding the margin.</li> <li> <strong>\(y_i f^*(x_i) &lt; 1\):</strong> Maximum pull (\(\alpha_i^* = \frac{c}{n}\)) – the point is violating the margin.</li> </ul> <p>This helps you remember which data points influence the decision boundary and how they do so.</p> <hr> <h4 id="support-vectors-the-pillars-of-svms"><strong>Support Vectors: The Pillars of SVMs</strong></h4> <p>The dual formulation of SVMs reveals that the weight vector \(w^*\) can be expressed as:</p> \[w^* = \sum_{i=1}^n \alpha_i^* y_i x_i.\] <p>Here, the examples \(x_i\) with \(\alpha_i^* &gt; 0\) (Few margin errors or “on the margin”) are known as <strong>support vectors</strong>. These are the critical data points that determine the hyperplane. Examples with \(\alpha_i^* = 0\) do not influence the solution, leading to <strong>sparsity</strong> in the SVM model. This sparsity is one of the key reasons why SVMs are computationally efficient for large datasets.</p> <h5 id="the-role-of-inner-products-in-the-dual-problem"><strong>The Role of Inner Products in the Dual Problem</strong></h5> <p>An intriguing aspect of the dual problem is that it depends on the input data \(x_i\) and \(x_j\) only through their <strong>inner product</strong>:</p> \[\langle x_j, x_i \rangle = x_j^T x_i.\] <p>This dependence on inner products allows us to generalize SVMs using <strong>kernel methods</strong>, where the inner product \(x_j^T x_i\) is replaced with a kernel function \(K(x_j, x_i)\). Kernels enable SVMs to implicitly operate in high-dimensional feature spaces without explicitly transforming the data, making it possible to model complex, non-linear decision boundaries.</p> <p>The kernelized dual problem is written as:</p> \[\sup_{\alpha} \sum_{i=1}^n \alpha_i - \frac{1}{2} \sum_{i,j=1}^{n} \alpha_i \alpha_j y_i y_j K(x_j, x_i),\] <p>subject to:</p> <ul> <li>\(\sum_{i=1}^n \alpha_i y_i = 0\),</li> <li>\(0 \leq \alpha_i \leq \frac{c}{n}\), for \(i = 1, \dots, n\).</li> </ul> <p>We’ll dive into kernels next and explore how this powerful trick enhances the usefulness of SVMs.</p> <hr> <h5 id="wrapping-up"><strong>Wrapping Up</strong></h5> <p>Complementary slackness conditions reveal much about the structure and workings of SVMs. They show how the margin, slack variables, and dual variables interact and highlight the pivotal role of support vectors. Moreover, the reliance on inner products paves the way for kernel methods, unlocking the power of SVMs for non-linear classification problems.</p> <p>In the next post, we’ll explore kernel functions in depth, including popular choices like Gaussian and polynomial kernels, and see how they influence SVM performance. See you!</p> <h5 id="references"><strong>References</strong></h5> <ul> <li>Math parts verification</li> <li><a href="https://www.stat.cmu.edu/~ryantibs/convexopt-F16/scribes/kkt-scribed.pdf" rel="external nofollow noopener" target="_blank"> KKT conditions - KKT conditions</a></li> <li><a href="https://math.stackexchange.com/questions/2162932/big-picture-behind-how-to-use-kkt-conditions-for-constrained-optimization" rel="external nofollow noopener" target="_blank">Big picture behind how to use KKT conditions for constrained optimization</a></li> <li><a href="https://davidrosenberg.github.io/mlcourse/Archive/2019/Notes/SVM-main-points.pdf" rel="external nofollow noopener" target="_blank">SVM: Main Takeaways from Duality</a></li> <li><a href="https://davidrosenberg.github.io/mlcourse/Archive/2019/Notes/convex-optimization.pdf" rel="external nofollow noopener" target="_blank">Extreme Abridgment of Boyd and Vandenberghe’s Convex Optimization</a></li> </ul> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Monishver Chandrasekaran. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1HD0LJE1KY"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1HD0LJE1KY");</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"Blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"A growing collection of my cool projects.",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"post-svm-solution-in-the-span-of-the-data",title:"SVM Solution in the Span of the Data",description:"This blog explores how the span property simplifies optimization in SVM and ridge regression, introduces the Representer Theorem, and highlights the computational benefits of kernelization.",section:"Posts",handler:()=>{window.location.href="/blog/2025/svm-solution-span-of-data/"}},{id:"post-understanding-the-kernel-trick",title:"Understanding the Kernel Trick",description:"A step-by-step exploration of kernel methods, unraveling their role in enabling powerful nonlinear modeling through the elegance of the kernel trick.",section:"Posts",handler:()=>{window.location.href="/blog/2025/kernel-trick/"}},{id:"post-unleashing-the-power-of-linear-models-tackling-nonlinearity-with-feature-maps",title:"Unleashing the Power of Linear Models - Tackling Nonlinearity with Feature Maps",description:"Explore how feature maps transform inputs, handle nonlinearities, and expand the expressiveness of linear models with practical examples and intuitive solutions.",section:"Posts",handler:()=>{window.location.href="/blog/2025/feature-maps/"}},{id:"post-demystifying-svms-understanding-complementary-slackness-and-support-vectors",title:"Demystifying SVMs - Understanding Complementary Slackness and Support Vectors",description:"A deep dive into the complementary slackness conditions in SVMs, exploring their connection to margins, support vectors, and kernelized optimization for powerful classification.",section:"Posts",handler:()=>{window.location.href="/blog/2025/svm-dual-problem/"}},{id:"post-the-dual-problem-of-svm",title:"The Dual Problem of SVM",description:"An in-depth exploration of the dual problem in SVMs, covering its mathematical foundation, Lagrangian formulation, duality principles, and complementary slackness for intuitive understanding.",section:"Posts",handler:()=>{window.location.href="/blog/2025/dual-problem/"}},{id:"post-subgradient-and-subgradient-descent",title:"Subgradient and Subgradient Descent",description:"An deep dive into subgradients, subgradient descent, and their application in optimizing non-differentiable functions like SVMs.",section:"Posts",handler:()=>{window.location.href="/blog/2025/subgradient/"}},{id:"post-support-vector-machines-svm-from-hinge-loss-to-optimization",title:"Support Vector Machines(SVM) - From Hinge Loss to Optimization",description:"Demystifying Support Vector Machines (SVM) - A step-by-step exploration of hinge loss, optimization, and gradient mechanics.",section:"Posts",handler:()=>{window.location.href="/blog/2025/svm/"}},{id:"post-understanding-the-maximum-margin-classifier",title:"Understanding the Maximum Margin Classifier",description:"An engaging walkthrough of maximum margin classifiers, exploring their foundations, geometric insights, and the transition to support vector machines.",section:"Posts",handler:()=>{window.location.href="/blog/2025/max-margin-classifier/"}},{id:"post-l1-and-l2-regularization-nuanced-details",title:"L1 and L2 Regularization - Nuanced Details",description:"A detailed explanation of L1 and L2 regularization, focusing on their theoretical insights, geometric interpretations, and practical implications for machine learning models.",section:"Posts",handler:()=>{window.location.href="/blog/2025/l1-l2-reg-indepth/"}},{id:"post-regularization-balancing-model-complexity-and-overfitting",title:"Regularization - Balancing Model Complexity and Overfitting",description:"Discover how regularization controls model complexity, reduces overfitting, and enhances generalization in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2025/regularization/"}},{id:"post-loss-functions-regression-and-classification",title:"Loss Functions - Regression and Classification",description:"Exploring regression and classification loss functions, with a deep dive into logistic regression and its role in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2025/loss-functions/"}},{id:"post-optimizing-stochastic-gradient-descent-key-recommendations-for-effective-training",title:"Optimizing Stochastic Gradient Descent - Key Recommendations for Effective Training",description:"A comprehensive collection of expert recommendations to enhance the performance and reliability of Stochastic Gradient Descent, ensuring smoother and faster convergence during training.",section:"Posts",handler:()=>{window.location.href="/blog/2025/sgd-tips/"}},{id:"post-gradient-descent-and-second-order-optimization-a-thorough-comparison",title:"Gradient Descent and Second-Order Optimization - A Thorough Comparison",description:"An in-depth exploration of Gradient Descent (GD) and Second-Order Gradient Descent (2GD), focusing on convergence behavior, mathematical derivations, and performance differences.",section:"Posts",handler:()=>{window.location.href="/blog/2024/gd-tips/"}},{id:"post-gradient-descent-convergence-prerequisites-and-detailed-derivation",title:"Gradient Descent Convergence - Prerequisites and Detailed Derivation",description:"Understanding the convergence of gradient descent with a fixed step size and proving its rate of convergence for convex, differentiable functions.",section:"Posts",handler:()=>{window.location.href="/blog/2024/gd-convergence/"}},{id:"post-understanding-stochastic-gradient-descent-sgd",title:"Understanding Stochastic Gradient Descent (SGD)",description:"A detailed guide to gradient descent variants, highlighting the mechanics, trade-offs, and practical insights of Stochastic Gradient Descent (SGD).",section:"Posts",handler:()=>{window.location.href="/blog/2024/SGD/"}},{id:"post-gradient-descent-a-detailed-walkthrough",title:"Gradient Descent - A Detailed Walkthrough",description:"An in-depth exploration of gradient descent, including its convergence and step size considerations.",section:"Posts",handler:()=>{window.location.href="/blog/2024/gradient-descent/"}},{id:"post-empirical-risk-minimization-erm",title:"Empirical Risk Minimization (ERM)",description:"Exploring Empirical Risk Minimization - Balancing approximation, estimation, and optimization errors to build effective supervised learning models.",section:"Posts",handler:()=>{window.location.href="/blog/2024/ERM/"}},{id:"post-understanding-the-supervised-learning-setup",title:"Understanding the Supervised Learning Setup",description:"An in-depth exploration of the supervised learning setup, covering key concepts like prediction functions, loss functions, risk evaluation, and the Bayes optimal predictor.",section:"Posts",handler:()=>{window.location.href="/blog/2024/supervised-learning/"}},{id:"post-timeline-of-machine-learning-history",title:"Timeline of Machine Learning History",description:"A concise timeline of machine learning&#39;s history, showcasing key milestones and breakthroughs that shaped the field.",section:"Posts",handler:()=>{window.location.href="/blog/2024/ml-history/"}},{id:"post-advanced-probability-concepts-for-machine-learning",title:"Advanced Probability Concepts for Machine Learning",description:"This blog explores key probability theory concepts, from distributions and Bayes&#39; Theorem to covariance and the Central Limit Theorem, emphasizing their critical application in machine learning and statistical modeling.",section:"Posts",handler:()=>{window.location.href="/blog/2024/probability-2/"}},{id:"post-understanding-the-basics-of-probability-theory-for-machine-learning",title:"Understanding the Basics of Probability Theory for Machine Learning",description:"This blog explores essential probability concepts and their significance in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2024/probability-1/"}},{id:"post-linear-algebra-prerequisites-for-machine-learning",title:"Linear Algebra - Prerequisites for Machine Learning",description:"This blog post covers the key linear algebra concepts and their applications in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2024/linear-algebra/"}},{id:"post-multivariate-calculus-prerequisites-for-machine-learning",title:"Multivariate Calculus - Prerequisites for Machine Learning",description:"This blog post explores key multivariate calculus concepts essential for understanding optimization in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2024/multivariate-calculus/"}},{id:"post-introduction-to-machine-learning-ml",title:"Introduction to Machine Learning(ML)",description:"An easy guide to machine learning, its applications, and how it connects to AI and human learning.",section:"Posts",handler:()=>{window.location.href="/blog/2024/intro-to-ml/"}},{id:"post-preface-amp-introduction",title:"Preface &amp; Introduction",description:"First blog post\u2014setting the stage for the journey ahead.",section:"Posts",handler:()=>{window.location.href="/blog/2024/preface-ml/"}},{id:"projects-mta-transit-time-prediction",title:"MTA Transit Time Prediction",description:"Leveraging real-time data and machine learning to predict bus arrival times in New York City with route-based and grid-based approaches.",section:"Projects",handler:()=>{window.location.href="/projects/1_project/"}},{id:"social-email",title:"email",section:"Socials",handler:()=>{window.open("mailto:%6D%6F%6E%69%73%68%76%65%72%63%68%61%6E%64%72%61%73%65%6B%61%72%61%6E@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"social-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/Monishver11","_blank")}},{id:"social-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/monishver","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>