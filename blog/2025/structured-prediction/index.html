<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="9O0EoPaLhgFjSIvAkDDoQK0gr49C2Wuxtgl3c0bXObM"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Structured Prediction and Multiclass SVM | Monishver Chandrasekaran </title> <meta name="author" content="Monishver Chandrasekaran"> <meta name="description" content="An in-depth yet intuitive walkthrough of structured prediction, covering sequence labeling, feature engineering, and scoring methods for complex outputs."> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/logo.png?e68e4955e21b20101db6e28a5a50abec"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://monishver11.github.io/blog/2025/structured-prediction/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class=" "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm sticky-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Monishver</span> Chandrasekaran </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/thoughts/">Thoughts </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title" style="font-weight: 400;">Structured Prediction and Multiclass SVM</h1> <p class="post-meta"> Created in April 13, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/ml"> <i class="fa-solid fa-hashtag fa-sm"></i> ML</a>   <a href="/blog/tag/math"> <i class="fa-solid fa-hashtag fa-sm"></i> Math</a>   ·   <a href="/blog/category/ml-nyu"> <i class="fa-solid fa-tag fa-sm"></i> ML-NYU</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Structured prediction is a powerful framework used when our output space is complex and structured — such as sequences, trees, or graphs — rather than simple class labels. This post builds on multiclass SVMs to delve deeper into structured prediction, exploring how we define and learn over complex output spaces, as well as the notions of joint feature representations and local compatibility scores.</p> <hr> <h5 id="what-is-structured-prediction"><strong>What is Structured Prediction?</strong></h5> <p>In standard classification, we predict a single label for each input—like identifying whether an image contains a cat or a dog.</p> <p>But what if our outputs aren’t that simple? What if the prediction itself has structure?</p> <p>That’s where <strong>structured prediction</strong> comes in. It refers to machine learning tasks where the output is not a single label but a <strong>structured object</strong>—like a sequence, a tree, or even a segmentation map. These outputs have dependencies and internal organization that we want to model directly.</p> <h5 id="example-1-part-of-speech-pos-tagging"><strong>Example 1: Part-of-Speech (POS) Tagging</strong></h5> <p>In POS tagging, we’re given a sentence and need to assign a grammatical label to each word—like “noun”, “verb”, or “pronoun”.</p> <p>Here’s an example:</p> \[\begin{aligned} x &amp;: [\text{START}],\ \text{He},\ \text{eats},\ \text{apples} \\ y &amp;: [\text{START}],\ \text{Pronoun},\ \text{Verb},\ \text{Noun} \end{aligned}\] <p>To formalize this:</p> <ul> <li> <p><strong>Vocabulary</strong><br> Words we might encounter, including a special <code class="language-plaintext highlighter-rouge">[START]</code> symbol and punctuation:</p> \[V = \text{All English words} \cup \{ \text{[START]}, \text{.} \}\] </li> <li> <p><strong>Input space</strong><br> A sequence of words of any length:</p> \[X = V^n, \quad n = 1, 2, 3, \dots\] </li> <li> <p><strong>Label set</strong><br> The set of possible POS tags:</p> \[P = \{ \text{START, Pronoun, Verb, Noun, Adjective} \}\] </li> <li> <p><strong>Output space</strong><br> A sequence of POS tags of the same length as the input:</p> \[Y = P^n, \quad n = 1, 2, 3, \dots\] </li> </ul> <p>This is a classic case of sequence labeling, where each position in the input has a corresponding label in the output.</p> <h5 id="example-2-action-grounding-in-long-form-videos"><strong>Example 2: Action Grounding in Long-Form Videos</strong></h5> <p>Structured prediction also shines in vision tasks like <strong>action grounding</strong>. Here, we’re given a long video and need to segment it and assign actions like “chopping” or “frying” to different time spans.</p> <ul> <li> <p><strong>Input</strong><br> A video frame is represented as a feature vector:</p> \[V = \mathbb{R}^D\] </li> <li> <p><strong>Input sequence</strong><br> A video is a sequence of these frame-level features:</p> \[X = V^n\] </li> <li> <p><strong>Label set</strong><br> The set of possible actions:</p> \[P = \{ \text{Slicing, Chopping, Frying, Washing, ...} \}\] </li> <li> <p><strong>Output sequence</strong><br> A sequence of actions corresponding to segments or frames:</p> \[Y = P^n\] </li> </ul> <p>This setup allows us to model real-world tasks where outputs have temporal structure—actions occur over time and are dependent on previous context. Structured prediction opens the door to powerful models that understand more than just isolated labels—they reason over entire sequences and structures.</p> <blockquote> <p><strong>But wait—doesn’t the model just predict POS tags for the given input? Where does context come in?</strong></p> </blockquote> <p>Great question! It might seem like we’re simply classifying each word. But in <strong>structured prediction</strong>, we <strong>don’t</strong> predict each tag independently. Instead, we predict the <strong>entire sequence jointly</strong>—which means the model <strong>does consider context</strong> while assigning tags.</p> <p><strong>How?</strong></p> <p>Structured prediction models use features that depend on both the current and <strong>previous tags</strong> (Markov dependencies). For example:</p> <ul> <li>If the previous tag is <code class="language-plaintext highlighter-rouge">Pronoun</code>, it’s likely the current tag is <code class="language-plaintext highlighter-rouge">Verb</code>.</li> <li>If the previous word is <code class="language-plaintext highlighter-rouge">He</code> and the current word is <code class="language-plaintext highlighter-rouge">runs</code>, the current tag is likely <code class="language-plaintext highlighter-rouge">Verb</code>.</li> </ul> <p>These dependencies are built into the model using <strong>joint feature vectors</strong> and <strong>structured scoring</strong>. Instead of a single-label classifier, we score the entire output sequence and pick the best-scoring one:</p> \[\hat{y} = \arg\max_{y \in Y(x)} h(x, y)\] <p>Now that we understand how structured models use context, let’s explore the hypothesis space that makes this possible.</p> <hr> <h5 id="hypothesis-space-for-structured-outputs"><strong>Hypothesis Space for Structured Outputs</strong></h5> <p>In structured prediction, the output space \(Y(x)\) is <strong>large and structured</strong>—its size depends on the input \(x\).</p> <p>We define:</p> <ul> <li> <p><strong>Base hypothesis space</strong>:</p> \[H = \{ h : X \times Y \to \mathbb{R} \}\] </li> <li> <p><strong>Compatibility score</strong>:</p> \[h(x, y)\] <p>gives a real-valued score that measures how compatible an input \(x\) is with a candidate output \(y\).</p> </li> <li> <p><strong>Final prediction function</strong>:</p> \[f(x) = \arg\max_{y \in Y} h(x, y), \quad f \in F\] </li> </ul> <p>So, our model chooses the <strong>most compatible output structure</strong> based on the scoring function.</p> <h5 id="designing-the-compatibility-score"><strong>Designing the Compatibility Score</strong></h5> <p>We use a <strong>linear model</strong> to define the compatibility score:</p> \[h(x, y) = \langle w, \Psi(x, y) \rangle\] <p>Where:</p> <ul> <li>\(w\) is a parameter vector to be learned.</li> <li>\(\Psi(x, y)\) is a <strong>joint feature representation</strong> of the input-output pair.</li> </ul> <p>Let’s break down how to construct this feature vector.</p> <p>Structured prediction leverages <strong>decomposable features</strong> that split complex structures into simpler parts.</p> <p><strong>Unary Features</strong></p> <p>Unary features depend on the label at a single position \(i\):</p> <ul> <li> <p>Example features:</p> \[\phi_1(x, y_i) = 1[x_i = \text{runs}] \cdot 1[y_i = \text{Verb}]\] \[\phi_2(x, y_i) = 1[x_i = \text{runs}] \cdot 1[y_i = \text{Noun}]\] \[\phi_3(x, y_i) = 1[x_{i-1} = \text{He}] \cdot 1[x_i = \text{runs}] \cdot 1[y_i = \text{Verb}]\] </li> </ul> <p><strong>Markov Features</strong></p> <p>Markov features capture dependencies between <strong>adjacent labels</strong> (like in HMMs):</p> <ul> <li> <p>Example features:</p> \[\theta_1(x, y_{i-1}, y_i) = 1[y_{i-1} = \text{Pronoun}] \cdot 1[y_i = \text{Verb}]\] \[\theta_2(x, y_{i-1}, y_i) = 1[y_{i-1} = \text{Pronoun}] \cdot 1[y_i = \text{Noun}]\] </li> </ul> <p>These features are key to modeling the <strong>structure</strong> in structured prediction tasks. By combining them across all positions in a sequence, we construct the full joint feature vector \(\Psi(x, y)\).</p> <hr> <p>Now that we’ve seen how structured prediction breaks down sequences into parts using Unary and Markov features, the next question is:</p> <p><strong>How do we combine these local components to score an entire sequence?</strong></p> <p>This leads us to the idea of <strong>local compatibility scores</strong>.</p> <h5 id="local-compatibility-score"><strong>Local Compatibility Score</strong></h5> <p>At each position \(i\) in the sequence, we compute a <strong>local feature vector</strong> that captures both the current label and the transition from the previous label.</p> <ul> <li> <p>Local feature vector: \(\Psi_i(x, y_{i-1}, y_i) = \big( \phi_1(x, y_i), \phi_2(x, y_i), \dots, \theta_1(x, y_{i-1}, y_i), \theta_2(x, y_{i-1}, y_i), \dots \big)\)</p> </li> <li> <p>Local compatibility score: \(\langle w, \Psi_i(x, y_{i-1}, y_i) \rangle\)</p> </li> </ul> <p>To get the <strong>total compatibility score</strong> for the input-output pair \((x, y)\), we <strong>sum these local scores</strong> over the sequence:</p> \[h(x, y) = \sum_i \langle w, \Psi_i(x, y_{i-1}, y_i) \rangle\] <p>This is equivalent to:</p> \[h(x, y) = \langle w, \Psi(x, y) \rangle\] <p>Where the <strong>global feature vector</strong> is the sum of all local feature vectors:</p> \[\Psi(x, y) = \sum_i \Psi_i(x, y_{i-1}, y_i)\] <p>This decomposition is what makes learning and inference tractable in structured models like CRFs, structured perceptrons, and structured SVMs.</p> <hr> <h5 id="lets-walk-through-the-logic-with-an-example-part-of-speech-pos-tagging-for-the-sentence"><strong>Let’s walk through the logic with an example: Part-of-Speech (POS) Tagging for the sentence</strong></h5> <p>Input (x): [START] He runs fast</p> <p>Goal: Predict the most likely sequence of POS tags:</p> <p>Output (y): [START] Pronoun Verb Adverb</p> <p><strong>Step 1: What are we learning?</strong></p> <p>We want to <strong>learn a scoring function</strong>:</p> \[h(x, y) = \langle w, \Psi(x, y) \rangle\] <p>This function gives a <strong>score</strong> to a candidate output sequence \(y\) for a given input \(x\). The higher the score, the more compatible we believe \(x\) and \(y\) are.</p> <p><strong>Step 2: Why structured outputs are different</strong></p> <p>In structured prediction, the output \(y\) isn’t just a single label—it’s a whole <strong>sequence</strong> (or tree, or grid, etc.).</p> <p>For our sentence, that means predicting:</p> <p>[Pronoun, Verb, Adverb]</p> <p>instead of a single class like just “Verb”.</p> <p><strong>Step 3: Representing compatibility with features</strong></p> <p>We use <strong>feature functions</strong> to capture useful information from \((x, y)\):</p> <ul> <li> <strong>Unary features</strong> look at the input and the label at a single position (e.g., “He” → “Pronoun”)</li> <li> <strong>Markov features</strong> look at <strong>transitions between labels</strong> (e.g., “Pronoun” → “Verb”)</li> </ul> <p>These become the building blocks of our model.</p> <p><strong>Step 4: Breaking down the full sequence</strong></p> <p>For a sequence of length 3 (ignoring [START] token), we define <strong>local features</strong> at each position \(i\):</p> <ul> <li>At \(i = 1\): “He” tagged as Pronoun</li> <li>At \(i = 2\): “runs” tagged as Verb</li> <li>At \(i = 3\): “fast” tagged as Adverb</li> </ul> <p>At each step, we build a <strong>local feature vector</strong>:</p> \[\Psi_i(x, y_{i-1}, y_i)\] <p>This vector includes both:</p> <ul> <li>Unary features for \(x_i\) and \(y_i\)</li> <li>Markov features for \(y_{i-1}\) and \(y_i\)</li> </ul> <p><strong>Step 5: Computing local scores</strong></p> <p>We compute a <strong>local score</strong> at each position:</p> \[\langle w, \Psi_i(x, y_{i-1}, y_i) \rangle\] <p>This tells us how well the current word and label (and label transition) fit the model.</p> <p>Do this for all positions \(i\) in the sequence.</p> <p><strong>Let’s walk through this sequence step-by-step.</strong></p> <p>At \(i = 1\) (Word: <em>He</em>, Tag: <em>Pronoun</em>)</p> <p>Since this is the first word, we assume the previous tag is <code class="language-plaintext highlighter-rouge">START</code>:</p> \[y_0 = \text{START}\] <p>We define:</p> \[\Psi_1(x, y_0, y_1) = \begin{cases} \phi_1(x_1 = \text{He}, y_1 = \text{Pronoun}) = 1 \\ \theta_1(y_0 = \text{START}, y_1 = \text{Pronoun}) = 1 \end{cases}\] <p>All other components of \(\Psi_1\) are zero.</p> <p>At \(i = 2\) (Word: <em>runs</em>, Tag: <em>Verb</em>)</p> \[y_1 = \text{Pronoun}, \quad y_2 = \text{Verb}\] <p>We define:</p> \[\Psi_2(x, y_1, y_2) = \begin{cases} \phi_2(x_2 = \text{runs}, y_2 = \text{Verb}) = 1 \\ \theta_2(y_1 = \text{Pronoun}, y_2 = \text{Verb}) = 1 \end{cases}\] <p>Other entries in \(\Psi_2\) are zero.</p> <p>At \(i = 3\) (Word: <em>fast</em>, Tag: <em>Adverb</em>)</p> \[y_2 = \text{Verb}, \quad y_3 = \text{Adverb}\] <p>We define:</p> \[\Psi_3(x, y_2, y_3) = \begin{cases} \phi_3(x_3 = \text{fast}, y_3 = \text{Adverb}) = 1 \\ \theta_3(y_2 = \text{Verb}, y_3 = \text{Adverb}) = 1 \end{cases}\] <p><strong>Step 6: Summing up the local scores</strong></p> <p>To score the full sequence \((x, y)\), we <strong>sum all local scores</strong>:</p> \[h(x, y) = \sum_i \langle w, \Psi_i(x, y_{i-1}, y_i) \rangle\] <p>This total score tells us how compatible this <strong>entire sequence of labels</strong> is with the input.</p> <p>We also define the <strong>global feature vector</strong> as:</p> \[\Psi(x, y) = \sum_i \Psi_i(x, y_{i-1}, y_i)\] <p>So that the score becomes:</p> \[h(x, y) = \langle w, \Psi(x, y) \rangle\] <p>So, in our example, this will be:</p> \[\Psi(x, y) = \Psi_1(x, y_0, y_1) + \Psi_2(x, y_1, y_2) + \Psi_3(x, y_2, y_3)\] <p>Then, the <strong>total compatibility score</strong> is:</p> \[h(x, y) = \langle w, \Psi(x, y) \rangle = \sum_{i=1}^3 \langle w, \Psi_i(x, y_{i-1}, y_i) \rangle\] <p><strong>Step 7: Prediction</strong></p> <p>Finally, to predict the best output sequence for a new input \(x\), we find:</p> \[f(x) = \arg\max_{y \in Y} \langle w, \Psi(x, y) \rangle\] <p>This means: “Find the label sequence \(y\) that gives the highest compatibility score with \(x\).”</p> <hr> <h5 id="summary-of-the-complete-flow"><strong>Summary of the Complete Flow</strong></h5> <ol> <li> <strong>Input</strong>: Sentence \(x =\) [START] He runs fast</li> <li> <strong>Output space</strong>: All possible tag sequences of same length</li> <li> <strong>For each sequence \(y\)</strong>: <ul> <li>Break it into local pairs: \((y_{i-1}, y_i)\)</li> <li>Construct local features \(\Psi_i(x, y_{i-1}, y_i)\)</li> <li>Compute local scores and sum them</li> </ul> </li> <li> <strong>Choose</strong> the sequence \(y\) with highest score \(h(x, y)\)</li> </ol> <p>We’ve now built a clear understanding of how compatibility scores work in structured prediction—by combining <strong>decomposable local features</strong> across a sequence. This formulation helps capture both local label associations and dependencies between adjacent labels.</p> <p>In the <strong>next section</strong>, we’ll dive into <strong>Structured Perceptron</strong> and <strong>Structured SVMs</strong>, where we learn how to train these models using mistake-driven updates and margin-based losses.</p> <p>Take care!</p> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Monishver Chandrasekaran. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1HD0LJE1KY"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1HD0LJE1KY");</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"Blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"A growing collection of my cool projects.",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-thoughts",title:"Thoughts",description:"",section:"Navigation",handler:()=>{window.location.href="/thoughts/"}},{id:"post-decision-trees-for-classification",title:"Decision Trees for Classification",description:"Explains what makes a good split, how impurity is quantified using Gini, Entropy, and misclassification error, and why trees are both powerful and interpretable.",section:"Posts",handler:()=>{window.location.href="/blog/2025/decision-trees-classification/"}},{id:"post-decision-trees-our-first-non-linear-classifier",title:"Decision Trees - Our First Non-Linear Classifier",description:"Learn how decision trees work for regression, including split criteria, overfitting control, and intuitive examples.",section:"Posts",handler:()=>{window.location.href="/blog/2025/decision-trees/"}},{id:"post-structured-perceptron-amp-structured-svm",title:"Structured Perceptron &amp; Structured SVM",description:"Understanding how Structured Perceptron and Structured SVM learn to predict structured outputs with interdependent components.",section:"Posts",handler:()=>{window.location.href="/blog/2025/structured-perceptron-svm/"}},{id:"post-structured-prediction-and-multiclass-svm",title:"Structured Prediction and Multiclass SVM",description:"An in-depth yet intuitive walkthrough of structured prediction, covering sequence labeling, feature engineering, and scoring methods for complex outputs.",section:"Posts",handler:()=>{window.location.href="/blog/2025/structured-prediction/"}},{id:"post-multiclass-classification-with-svm",title:"Multiclass Classification with SVM",description:"Learn how Support Vector Machines extend to multiclass classification with an intuitive breakdown of margin concepts, loss derivation, and the multiclass hinge loss formulation.",section:"Posts",handler:()=>{window.location.href="/blog/2025/multiclass-svm/"}},{id:"post-multiclass-logistic-regression-amp-multiclass-perceptron-algorithm",title:"Multiclass Logistic Regression &amp; Multiclass Perceptron Algorithm",description:"Learn the essentials of multiclass classification, focusing on logistic regression, perceptron algorithms, and efficient model building techniques.",section:"Posts",handler:()=>{window.location.href="/blog/2025/multiclass-loss/"}},{id:"post-multiclass-classification-overview",title:"Multiclass Classification - Overview",description:"Learn how One-vs-All and One-vs-One extend binary classification to multiclass problems, their key differences, and best use cases.",section:"Posts",handler:()=>{window.location.href="/blog/2025/multiclass/"}},{id:"post-gaussian-regression-a-bayesian-approach-to-linear-regression",title:"Gaussian Regression - A Bayesian Approach to Linear Regression",description:"This guide explores Gaussian regression, deriving its closed-form posterior, linking MAP estimation to ridge regression, and explaining predictive uncertainty for Bayesian inference.",section:"Posts",handler:()=>{window.location.href="/blog/2025/gaussian-regression/"}},{id:"post-my-understanding-of-quot-efficient-algorithms-for-online-decision-problems-quot-paper",title:"My Understanding of &quot;Efficient Algorithms for Online Decision Problems&quot; Paper",description:"A breakdown of Follow the Perturbed Leader (FPL) from Kalai &amp; Vempala\u2019s (2005) paper, &quot;Efficient Algorithms for Online Decision Problems.&quot; This blog explores how FPL improves online decision-making, minimizes regret, and extends to structured problems like shortest paths and adaptive Huffman coding.",section:"Posts",handler:()=>{window.location.href="/blog/2025/FPL-proof/"}},{id:"post-follow-the-leader-fl-and-follow-the-perturbed-leader-fpl-in-online-learning",title:"Follow the Leader (FL) and Follow the Perturbed Leader (FPL) in Online Learning...",description:"Discover how Follow the Leader (FL) and Follow the Perturbed Leader (FPL) work in online learning, their mathematical foundations, and how perturbations help achieve better stability and regret bounds.",section:"Posts",handler:()=>{window.location.href="/blog/2025/FPL/"}},{id:"post-bayesian-conditional-models",title:"Bayesian Conditional Models",description:"Learn how Bayesian conditional models leverage prior knowledge, posterior updates, and predictive distributions to make principled, uncertainty-aware predictions in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2025/bayes-conditional-models/"}},{id:"post-on-line-to-batch-conversion",title:"On-line to Batch Conversion",description:"Understanding how online learning algorithms can be used to derive hypotheses with small generalization error in a stochastic setting.",section:"Posts",handler:()=>{window.location.href="/blog/2025/online-to-batch/"}},{id:"post-randomized-weighted-majority-algorithm",title:"Randomized Weighted Majority Algorithm",description:"Learn how the Randomized Weighted Majority (RWM) Algorithm leverages probabilistic prediction to minimize regret and defend against adversarial strategies in online learning environments.",section:"Posts",handler:()=>{window.location.href="/blog/2025/RWM/"}},{id:"post-bayesian-decision-theory-concepts-and-recap",title:"Bayesian Decision Theory - Concepts and Recap",description:"A comprehensive guide to Bayesian decision theory, exploring its key components, point estimation, loss functions, and connections to classical probability modeling.",section:"Posts",handler:()=>{window.location.href="/blog/2025/bayes-decision-theory/"}},{id:"post-reinforcement-learning-an-introductory-guide",title:"Reinforcement Learning - An Introductory Guide",description:"Explore the foundations of intelligence, decision-making principles, and their application in reinforcement learning.",section:"Posts",handler:()=>{window.location.href="/blog/2025/rl-intro/"}},{id:"post-conjugate-priors-and-bayes-point-estimates",title:"Conjugate Priors and Bayes Point Estimates",description:"Learn how conjugate priors streamline Bayesian inference and discover  ways to summarize posterior distributions using Bayes point estimates.",section:"Posts",handler:()=>{window.location.href="/blog/2025/bayes-point-estimate/"}},{id:"post-doubling-trick-a-clever-strategy-to-handle-unknown-horizons",title:"Doubling Trick - A Clever Strategy to Handle Unknown Horizons",description:"Discover how the Doubling Trick enables online algorithms to adapt to unknown horizons, maintaining competitive regret bounds.",section:"Posts",handler:()=>{window.location.href="/blog/2025/doubling-trick/"}},{id:"post-exponential-weighted-average-algorithm",title:"Exponential Weighted Average Algorithm",description:"Delve into the Exponential Weighted Average Algorithm, its regret bounds, and the mathematical proof ensuring efficient loss minimization.",section:"Posts",handler:()=>{window.location.href="/blog/2025/EWA/"}},{id:"post-bayesian-machine-learning-mathematical-foundations",title:"Bayesian Machine Learning - Mathematical Foundations",description:"A beginner-friendly guide to Bayesian statistics, explaining priors, likelihoods, posteriors, and real-world examples like coin-flipping to build a clear and intuitive understanding.",section:"Posts",handler:()=>{window.location.href="/blog/2025/Bayesian-ML/"}},{id:"post-understanding-the-weighted-majority-algorithm-in-online-learning",title:"Understanding the Weighted Majority Algorithm in Online Learning",description:"Explore how the Weighted Majority Algorithm achieves robust bounds for adversarial settings by adapting expert weights with every mistake.",section:"Posts",handler:()=>{window.location.href="/blog/2025/WMA/"}},{id:"post-online-learning-in-ml-a-beginner-s-guide-to-adaptive-learning",title:"Online Learning in ML - A Beginner\u2019s Guide to Adaptive Learning",description:"Learn how online learning transforms machine learning by handling dynamic, real-time data and adversarial scenarios. Explore its advantages, real-world applications, and key concepts like regret minimization and the Halving Algorithm in this beginner-friendly guide to adaptive AI.",section:"Posts",handler:()=>{window.location.href="/blog/2025/Online-Learning/"}},{id:"post-multivariate-gaussian-distribution-and-naive-bayes",title:"Multivariate Gaussian Distribution and Naive Bayes",description:"Dive into the multivariate Gaussian distribution, its role in probabilistic modeling, and how it powers Naive Bayes classifiers with practical insights and mathematical intuition.",section:"Posts",handler:()=>{window.location.href="/blog/2025/Multivariate-GNB/"}},{id:"post-gaussian-naive-bayes-a-natural-extension",title:"Gaussian Naive Bayes - A Natural Extension",description:"Explore how Gaussian Naive Bayes adapts to continuous inputs, including parameter estimation, decision boundaries, and its relation to logistic regression.",section:"Posts",handler:()=>{window.location.href="/blog/2025/NB-continuous-features/"}},{id:"post-an-introduction-to-generative-models-naive-bayes-for-binary-features",title:"An Introduction to Generative Models - Naive Bayes for Binary Features",description:"Learn the fundamentals of Naive Bayes, from its conditional independence assumption to the maximum likelihood estimation (MLE) of parameters, using a binary feature example.",section:"Posts",handler:()=>{window.location.href="/blog/2025/generative-models/"}},{id:"post-generalized-linear-models-explained-leveraging-mle-for-regression-and-classification",title:"Generalized Linear Models Explained - Leveraging MLE for Regression and Classification",description:"Explore how Maximum Likelihood Estimation (MLE) forms the backbone of generalized linear models, enabling robust solutions for regression, classification, and beyond.",section:"Posts",handler:()=>{window.location.href="/blog/2025/MLE/"}},{id:"post-unveiling-probabilistic-modeling",title:"Unveiling Probabilistic Modeling",description:"Explore the fundamentals of probabilistic modeling and how it enhances our understanding of linear regression, from parameter estimation to error distribution.",section:"Posts",handler:()=>{window.location.href="/blog/2025/probabilistic-modeling/"}},{id:"post-svm-solution-in-the-span-of-the-data",title:"SVM Solution in the Span of the Data",description:"This blog explores how the span property simplifies optimization in SVM and ridge regression, introduces the Representer Theorem, and highlights the computational benefits of kernelization.",section:"Posts",handler:()=>{window.location.href="/blog/2025/svm-solution-span-of-data/"}},{id:"post-understanding-the-kernel-trick",title:"Understanding the Kernel Trick",description:"A step-by-step exploration of kernel methods, unraveling their role in enabling powerful nonlinear modeling through the elegance of the kernel trick.",section:"Posts",handler:()=>{window.location.href="/blog/2025/kernel-trick/"}},{id:"post-unleashing-the-power-of-linear-models-tackling-nonlinearity-with-feature-maps",title:"Unleashing the Power of Linear Models - Tackling Nonlinearity with Feature Maps",description:"Explore how feature maps transform inputs, handle nonlinearities, and expand the expressiveness of linear models with practical examples and intuitive solutions.",section:"Posts",handler:()=>{window.location.href="/blog/2025/feature-maps/"}},{id:"post-demystifying-svms-understanding-complementary-slackness-and-support-vectors",title:"Demystifying SVMs - Understanding Complementary Slackness and Support Vectors",description:"A deep dive into the complementary slackness conditions in SVMs, exploring their connection to margins, support vectors, and kernelized optimization for powerful classification.",section:"Posts",handler:()=>{window.location.href="/blog/2025/svm-dual-problem/"}},{id:"post-the-dual-problem-of-svm",title:"The Dual Problem of SVM",description:"An in-depth exploration of the dual problem in SVMs, covering its mathematical foundation, Lagrangian formulation, duality principles, and complementary slackness for intuitive understanding.",section:"Posts",handler:()=>{window.location.href="/blog/2025/dual-problem/"}},{id:"post-subgradient-and-subgradient-descent",title:"Subgradient and Subgradient Descent",description:"An deep dive into subgradients, subgradient descent, and their application in optimizing non-differentiable functions like SVMs.",section:"Posts",handler:()=>{window.location.href="/blog/2025/subgradient/"}},{id:"post-support-vector-machines-svm-from-hinge-loss-to-optimization",title:"Support Vector Machines(SVM) - From Hinge Loss to Optimization",description:"Demystifying Support Vector Machines (SVM) - A step-by-step exploration of hinge loss, optimization, and gradient mechanics.",section:"Posts",handler:()=>{window.location.href="/blog/2025/svm/"}},{id:"post-understanding-the-maximum-margin-classifier",title:"Understanding the Maximum Margin Classifier",description:"An engaging walkthrough of maximum margin classifiers, exploring their foundations, geometric insights, and the transition to support vector machines.",section:"Posts",handler:()=>{window.location.href="/blog/2025/max-margin-classifier/"}},{id:"post-l1-and-l2-regularization-nuanced-details",title:"L1 and L2 Regularization - Nuanced Details",description:"A detailed explanation of L1 and L2 regularization, focusing on their theoretical insights, geometric interpretations, and practical implications for machine learning models.",section:"Posts",handler:()=>{window.location.href="/blog/2025/l1-l2-reg-indepth/"}},{id:"post-regularization-balancing-model-complexity-and-overfitting",title:"Regularization - Balancing Model Complexity and Overfitting",description:"Discover how regularization controls model complexity, reduces overfitting, and enhances generalization in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2025/regularization/"}},{id:"post-loss-functions-regression-and-classification",title:"Loss Functions - Regression and Classification",description:"Exploring regression and classification loss functions, with a deep dive into logistic regression and its role in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2025/loss-functions/"}},{id:"post-optimizing-stochastic-gradient-descent-key-recommendations-for-effective-training",title:"Optimizing Stochastic Gradient Descent - Key Recommendations for Effective Training",description:"A comprehensive collection of expert recommendations to enhance the performance and reliability of Stochastic Gradient Descent, ensuring smoother and faster convergence during training.",section:"Posts",handler:()=>{window.location.href="/blog/2025/sgd-tips/"}},{id:"post-gradient-descent-and-second-order-optimization-a-thorough-comparison",title:"Gradient Descent and Second-Order Optimization - A Thorough Comparison",description:"An in-depth exploration of Gradient Descent (GD) and Second-Order Gradient Descent (2GD), focusing on convergence behavior, mathematical derivations, and performance differences.",section:"Posts",handler:()=>{window.location.href="/blog/2024/gd-tips/"}},{id:"post-gradient-descent-convergence-prerequisites-and-detailed-derivation",title:"Gradient Descent Convergence - Prerequisites and Detailed Derivation",description:"Understanding the convergence of gradient descent with a fixed step size and proving its rate of convergence for convex, differentiable functions.",section:"Posts",handler:()=>{window.location.href="/blog/2024/gd-convergence/"}},{id:"post-understanding-stochastic-gradient-descent-sgd",title:"Understanding Stochastic Gradient Descent (SGD)",description:"A detailed guide to gradient descent variants, highlighting the mechanics, trade-offs, and practical insights of Stochastic Gradient Descent (SGD).",section:"Posts",handler:()=>{window.location.href="/blog/2024/SGD/"}},{id:"post-gradient-descent-a-detailed-walkthrough",title:"Gradient Descent - A Detailed Walkthrough",description:"An in-depth exploration of gradient descent, including its convergence and step size considerations.",section:"Posts",handler:()=>{window.location.href="/blog/2024/gradient-descent/"}},{id:"post-empirical-risk-minimization-erm",title:"Empirical Risk Minimization (ERM)",description:"Exploring Empirical Risk Minimization - Balancing approximation, estimation, and optimization errors to build effective supervised learning models.",section:"Posts",handler:()=>{window.location.href="/blog/2024/ERM/"}},{id:"post-understanding-the-supervised-learning-setup",title:"Understanding the Supervised Learning Setup",description:"An in-depth exploration of the supervised learning setup, covering key concepts like prediction functions, loss functions, risk evaluation, and the Bayes optimal predictor.",section:"Posts",handler:()=>{window.location.href="/blog/2024/supervised-learning/"}},{id:"post-timeline-of-machine-learning-history",title:"Timeline of Machine Learning History",description:"A concise timeline of machine learning&#39;s history, showcasing key milestones and breakthroughs that shaped the field.",section:"Posts",handler:()=>{window.location.href="/blog/2024/ml-history/"}},{id:"post-advanced-probability-concepts-for-machine-learning",title:"Advanced Probability Concepts for Machine Learning",description:"This blog explores key probability theory concepts, from distributions and Bayes&#39; Theorem to covariance and the Central Limit Theorem, emphasizing their critical application in machine learning and statistical modeling.",section:"Posts",handler:()=>{window.location.href="/blog/2024/probability-2/"}},{id:"post-understanding-the-basics-of-probability-theory-for-machine-learning",title:"Understanding the Basics of Probability Theory for Machine Learning",description:"This blog explores essential probability concepts and their significance in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2024/probability-1/"}},{id:"post-linear-algebra-prerequisites-for-machine-learning",title:"Linear Algebra - Prerequisites for Machine Learning",description:"This blog post covers the key linear algebra concepts and their applications in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2024/linear-algebra/"}},{id:"post-multivariate-calculus-prerequisites-for-machine-learning",title:"Multivariate Calculus - Prerequisites for Machine Learning",description:"This blog post explores key multivariate calculus concepts essential for understanding optimization in machine learning.",section:"Posts",handler:()=>{window.location.href="/blog/2024/multivariate-calculus/"}},{id:"post-introduction-to-machine-learning-ml",title:"Introduction to Machine Learning(ML)",description:"An easy guide to machine learning, its applications, and how it connects to AI and human learning.",section:"Posts",handler:()=>{window.location.href="/blog/2024/intro-to-ml/"}},{id:"post-preface-amp-introduction",title:"Preface &amp; Introduction",description:"First blog post\u2014setting the stage for the journey ahead.",section:"Posts",handler:()=>{window.location.href="/blog/2024/preface-ml/"}},{id:"news-spring-2025-semester-update",title:"Spring 2025 Semester Update",description:"",section:"News",handler:()=>{window.location.href="/news/announcement_1/"}},{id:"news-sharing-personal-reflections-thoughts-tab-thoughts",title:"Sharing personal reflections - [Thoughts Tab](/thoughts/)",description:"",section:"News"},{id:"projects-mta-transit-time-prediction",title:"MTA Transit Time Prediction",description:"Leveraging real-time data and machine learning to predict bus arrival times in New York City with route-based and grid-based approaches.",section:"Projects",handler:()=>{window.location.href="/projects/1_project/"}},{id:"social-email",title:"email",section:"Socials",handler:()=>{window.open("mailto:%6D%6F%6E%69%73%68%76%65%72%63%68%61%6E%64%72%61%73%65%6B%61%72%61%6E@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"social-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/Monishver11","_blank")}},{id:"social-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/monishver","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>